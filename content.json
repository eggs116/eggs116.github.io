[{"title":"纯CSS画各种图形","date":"2018-10-29T02:04:13.000Z","path":"CSS_border_graph/","text":"在实际应用中很多地方会用到一些小的形状图标及显示框等各种图形，而这时候如果使用图片不仅不能自适应内容还会在加载页面时增加图片请求从而降低页面性能，此时我们就可以用纯CSS的各种属性来解决这个问题了 CSS之border前言由于我们下面介绍的方法大多数都要用到border这个样式属性，所以先介绍一下它，如果想对border进一步了解，可以翻看我前面的那篇博客。最初border是用来给元素加边框的，随着CSS的发展和实际开发的需求，border被用在更多地方，比如用border的属性实现椭圆、梯形、心形等各种图形以及各种对话气泡上，在这里我们先看一下border的四个边属性12345678.border&#123; width: 0; height: 0; border-top: 50px solid red; border-right: 50px dashed blue; border-bottom: 50px solid yellow; border-left: 50px solid green;&#125; 注：如果要实现没有下边框，也就是没有上图中的黄色部分，则应该把上面代码中的border-bottom的颜色yellow改为transparent而不是把border-bottom去掉，两种做法的区别见下图，第一个是改为transparent，第二个是直接去掉border-bottom属性 矩形正方形12345.square&#123; width: 0; height: 0; border: 50px solid yellowgreen;&#125; 长方形12345678.square&#123; width: 0; height: 0; border-top: 50px solid yellowgreen; border-right: 100px solid yellowgreen; border-bottom: 50px solid yellowgreen; border-left: 100px solid yellowgreen;&#125; 平行四边形12345678910.parallelogram&#123; width: 100px; height: 50px; -webkit-transform: skew(20deg);/* Safari 和 Chrome */ -moz-transform: skew(20deg);/* Firefox */ -o-transform: skew(20deg);/* Opera */ -ms-transform: skew(20deg);/* IE 9 */ transform: skew(20deg); background: yellowgreen;&#125; 注：transform是CSS3的属性，skew()为倾斜角度，括号中分别为沿X轴和Y轴两个值，用逗号分隔，当只有一个值时默认为沿X轴倾斜，允许负值（反方向），这里我就不贴图了，感兴趣的话可以拿上面那段代码改改试试 菱形123456789101112131415.diamond&#123; width: 100px; height: 100px; -webkit-transform-origin: 0 100%; -moz-transform-origin: 0 100%; -o-transform-origin: 0 100%; -ms-transform-origin: 0 100%; transform-origin: 0 100%; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -o-transform: rotate(45deg); -ms-transform: rotate(45deg); transform: rotate(45deg); background: yellowgreen;&#125; 注：transform-origin规定旋转基点，rotate()旋转角度 梯形梯形-向上1234567.trapezoid-top&#123; width: 100px; height: 0; border-bottom: 100px solid yellowgreen; border-right: 50px solid transparent; border-left: 50px solid transparent;&#125; 如果直接看上面的代码不太明白，可以看下面的图例这张图其实跟CSS之border前言中的图一样，只是这里的左右边框宽度跟上下边框宽度不一样，当然当这四种颜色相同时就是我们的2.1中长方形的样子了，对比这张图跟最终的效果图有什么不一样？对了，就是我们上面提到过的把borer-top属性去掉，那就成了下面这种样子然后我们再把左右边框变成透明的就OK了怎么样，是不是跟上面的效果图一样了。理解了这个，下面的梯形面向各个方向我们就不详细解释原理了 梯形-向下1234567.trapezoid-bottom&#123; width: 100px; height: 0; border-top: 100px solid yellowgreen; border-right: 50px solid transparent; border-left: 50px solid transparent;&#125; 没错，就是把上面的代码中的bottom改成top即可 梯形-向左1234567.trapezoid-left&#123; width: 100px; height: 100px; border-right: 100px solid yellowgreen; border-top: 50px solid transparent; border-bottom: 50px solid transparent;&#125; 注：这里的height指定了外边框的长度，所以必须有，否则梯形就变成了三角形 梯形-向右1234567.trapezoid-right&#123; width: 100px; height: 100px; border-left: 100px solid yellowgreen; border-top: 50px solid transparent; border-bottom: 50px solid transparent;&#125; 圆角梯形12345678910111213141516.trapezoid-radius&#123; width: 100px; height: 40px; background: yellowgreen; border-radius: .5em .5em 0 0; -webkit-transform: scaleY(1.3) perspective(.5em) rotateX(5deg); -moz-transform: scaleY(1.3) perspective(.5em) rotateX(5deg); -ms-transform: scaleY(1.3) perspective(.5em) rotateX(5deg); -o-transform: scaleY(1.3) perspective(.5em) rotateX(5deg); transform: scaleY(1.3) perspective(.5em) rotateX(5deg);/*scaleY: 纵轴放大1.3倍，使梯形高度等于height；perspective:3d透视效果，元素距离视图的距离*/ -webkit-transform-origin: bottom; -moz-transform-origin: bottom; -ms-transform-origin: bottom; -o-transform-origin: bottom; transform-origin: bottom;/*以底轴为基轴*/&#125; 圆角梯形的实现原理跟其它的是不同的，圆角梯形是先实现圆角矩形，然后给矩形做3D变换，让它以底边框为基轴，向Z轴方向倾斜，视觉上就形成了圆角梯形 三角形三角形-向上123456.triangle-top &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-color: transparent transparent yellowgreen;&#125; 这里border-color有三个值，第一个代表上边框颜色，第二个代表左右边框颜色，第三个代表下边框颜色，关于这些在我上一篇博客中有详细的描述，感兴趣的话可以看看。其实还有别的写法，比如下面这样123456.triangle-top &#123; width: 0; height: 0; border: 50px solid transparent; border-bottom: 50px solid yellowgreen;&#125; 这种写法可以实现等腰三角形而非等边三角形 三角形-向下123456.triangle-bottom &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-color: yellowgreen transparent transparent;&#125; 三角形-向左123456.triangle-left &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-color: transparent yellowgreen transparent transparent;&#125; 三角形-向右123456.triangle-right &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-color: transparent transparent transparent yellowgreen;&#125; 三角形-左上123456.triangle-ltop &#123; width: 0; height: 0; border-top: 100px solid yellowgreen; border-right: 100px solid transparent;&#125; 三角形-右上123456.triangle-rtop &#123; width: 0; height: 0; border-right: 100px solid yellowgreen; border-bottom: 100px solid transparent;&#125; 三角形-左下123456.triangle-lbottom &#123; width: 0; height: 0; border-left: 100px solid yellowgreen; border-top: 100px solid transparent;&#125; 三角形-右下123456.triangle-rbottom &#123; width: 0; height: 0; border-bottom: 100px solid yellowgreen; border-left: 100px solid transparent;&#125; 三角形-上下-对角12345678.triangle-tbottom-diagonal &#123; width: 0; height: 0; border-top: 50px solid yellowgreen; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 50px solid yellowgreen;&#125; 其实是向上的三角和向下的三角的总和，不信可以把border-top和border-bottom的颜色改成不一样的就会发现了 三角形-上下-覆盖1234567891011121314151617181920.triangle-tbottom-cover &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid yellowgreen; position: relative;&#125;.triangle-tbottom-cover:after &#123; content: \" \"; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid yellowgreen; position: absolute; top: 50px; left: -50px;&#125; 其实是原理跟上一个一样，上下三角形要覆盖所以用到了定位而且把上下三角形分给了当前元素和当前元素的伪元素:after调整.triangle-tbottom-cover:after的top值即可得到六角形 三角形-上下-时间沙漏123456789101112131415161718192021.triangle-tbottom-time &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 60px solid yellowgreen; position: relative; margin-top: 50px&#125;.triangle-tbottom-time:after &#123; content: \" \"; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 60px solid yellowgreen; position: absolute; top: -40px; left: -50px;&#125; 跟上一个类似，只是定位的距离做了一些改变 圆12345678.semicircle &#123; width: 100px; height: 100px; background: yellowgreen; -webkit-border-radius: 50%; -moz-border-radius: 50%; border-radius: 50%;&#125; 注：宽高要相等，否则就是椭圆了 同心圆123456789.circle-circle &#123; width: 100px; height: 100px; border: 20px solid #669; background: #fff; -moz-border-radius: 100px; -webkit-border-radius: 100px; border-radius: 100px;&#125; 椭圆-水平12345678.oval-horizontal &#123; width: 100px; height: 50px; background: yellowgreen; -webkit-border-radius: 50px/25px; -moz-border-radius: 50px/25px; border-radius: 50px/25px;&#125; 注：水平椭圆即宽度&gt;高度；在本例中border-radius的取值，第一个值为宽度的一半即半长轴，第二个值为高度的一半即半短轴，但也可以直接写成border-radius:50%即宽高都各取一半 椭圆-垂直12345678.oval-vertical &#123; width: 50px; height: 100px; background: yellowgreen; -webkit-border-radius: 25px/50px -moz-border-radius: 25px/50px; border-radius: 25px/50px;&#125; 注：水平椭圆即宽度&lt;高度；在本例中border-radius的取值，第一个值为宽度的一半即半短轴，第二个值为高度的一半即半长轴，但也可以直接写成border-radius:50%即宽高都各取一半 表图123456789.chartColorful &#123; width: 0; height: 0; border-top: 50px solid red; border-right: 50px solid blue; border-bottom: 50px solid yellow; border-left: 50px solid green;-moz-border-radius: 50px; -webkit-border-radius:50px; border-radius: 50%;&#125; 其实这种写法跟1中CSS之border前言一样，只是在那个基础上增加了圆角弧度border-radius而已 半圆-上半圆12345678.semicircle-top &#123; width: 100px;/*直径*/ height: 50px;/*半径*/ background: yellowgreen; -webkit-border-radius: 100px 100px 0 0; -moz-border-radius: 100px 100px 0 0; border-radius: 100px 100px 0 0;/*半圆弧度为直径*/&#125; border-radius中取值的顺序为左上角 右上角 右下角 左下角，具体请看我的博客CSS之border详解 半圆-下半圆12345678.semicircle-bottom &#123; width: 100px;/*直径*/ height: 50px;/*半径*/ background: yellowgreen; -webkit-border-radius: 0 0 100px 100px; -moz-border-radius: 0 0 100px 100px; border-radius: 0 0 100px 100px;/*半圆弧度为直径*/&#125; 半圆-左半圆12345678.semicircle-left &#123; width: 50px;/*半径*/ height: 100px;/*直径*/ background: yellowgreen; -webkit-border-radius: 100px 0 0 100px; -moz-border-radius: 100px 0 0 100px; border-radius: 100px 0 0 100px;/*半圆弧度为直径*/&#125; 半圆-右半圆12345678.semicircle-right &#123; width: 50px;/*半径*/ height: 100px;/*直径*/ background: yellowgreen; -webkit-border-radius: 0 100px 100px 0; -moz-border-radius: 0 100px 100px 0; border-radius: 0 100px 100px 0;/*半圆弧度为直径*/&#125; 四分之一圆-上、下、左、右123456789.quarterCircle &#123; width: 0; height: 0; border-top: 50px solid yellowgreen; border-right: 50px solid transparent; border-left: 50px solid transparent; -moz-border-radius: 50px; -webkit-border-radius:50px; border-radius: 50%;&#125; 跟前面三角形对应的实现方法一样，只是在三角形的基础上加上border-radius：50%即可，所以这里就不再重复写了，如果需要可以在评论去留言 四分之一圆-左上12345678.quarterCircle-ltop &#123; width: 50px; height: 50px; background: yellowgreen; -moz-border-radius: 100% 0 0 0; -webkit-border-radius: 100% 0 0 0; border-radius: 100% 0 0 0;&#125; 注：因为这里画的是四分之一圆，所以宽高即为半径，而border-radius的取值等于半径时即可成圆的弧度，所以这里border-radius取值为100%，当然也可以不用百分比表示，而用像素值50px，原理是一样的当border-radius取值为50%时是如下形状 四分之一圆-右上12345678.quarterCircle-rtop &#123; width: 50px; height: 50px; background: yellowgreen; -moz-border-radius: 100% 0 0 0; -webkit-border-radius: 100% 0 0 0; border-radius:0 100% 0 0;&#125; 四分之一圆-右下12345678.quarterCircle-rbottom &#123; width: 50px; height: 50px; background: yellowgreen; -moz-border-radius: 100% 0 0 0; -webkit-border-radius: 100% 0 0 0; border-radius:0 0 100% 0;&#125; 四分之一圆-左下12345678.quarterCircle-lbottom &#123; width: 50px; height: 50px; background: yellowgreen; -moz-border-radius: 100% 0 0 0; -webkit-border-radius: 100% 0 0 0; border-radius:0 0 0 100%;&#125; 四分之三圆-上开口123456789.chart-top &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-top-color: transparent; -moz-border-radius:50%; -webkit-border-radius:50%; border-radius:50%;&#125; 四分之三圆-下开口123456789.chart-bottom &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-bottom-color: transparent; -moz-border-radius:50%; -webkit-border-radius:50%; border-radius:50%;&#125; 四分之三圆-左开口123456789.chart-left &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-left-color: transparent; -moz-border-radius:50%; -webkit-border-radius:50%; border-radius:50%;&#125; 四分之三圆-右开口123456789.chart-right &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-right-color: transparent; -moz-border-radius:50%; -webkit-border-radius:50%; border-radius:50%;&#125; 书签12345678.bookmark&#123; width: 0; height: 0; border-top: 50px solid yellowgreen; border-left: 30px solid yellowgreen; border-right: 30px solid yellowgreen; border-bottom: 30px solid transparent;&#125; 有两种方法，这种写法书签的高度是由border-top的宽度50px与border-bottom的宽度30px相加得到的,其实跟CSS之border前言中的第二张图原理是一样的1234567.bookmark2&#123; width: 0; height: 100px; border-left: 50px solid green; border-right: 50px solid yellowgreen; border-bottom: 35px solid transparent;&#125; 这种方法书签的高度是由height确定的，为了便于理解，这里把左右边框颜色做了区分 胶囊12345678.capsule &#123; width: 100px; height: 44px; background: yellowgreen; -moz-border-radius: 22px; -webkit-border-radius: 22px; border-radius: 22px;&#125; 这种方法书签的高度是由height确定的，为了便于理解，这里把左右边框颜色做了区分注：border-radius的取值为高度的一半即可（胶囊其实就是两侧为半圆形，中间为矩形的图形，为实现两侧的半圆形让border-radius的值为高度的一半即半径即可），当宽高交换时即为垂直方向上的胶囊，此处不再列举 半胶囊12345678.capsule-top &#123; width: 40px; height: 60px; background: yellowgreen; -moz-border-radius: 22px 22px 0 0; -webkit-border-radius: 22px 22px 0 0; border-radius: 22px 22px 0 0;&#125; 倾斜半胶囊12345678910111213.capsule-top-r45 &#123; width: 40px; height: 60px; background: yellowgreen; -moz-border-radius: 22px 22px 0 0; -webkit-border-radius: 22px 22px 0 0; border-radius: 22px 22px 0 0; -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); transform: rotate(-45deg);&#125; 其实就是让半胶囊旋转倾斜一定角度 心形心形其实是由半胶囊组成的1234567891011121314151617181920212223242526272829303132333435363738.heart &#123; position: relative;&#125;.heart:before,.heart:after &#123; width: 40px; height: 60px; position: absolute; content: \"\"; left: 50px; top: 0; background: yellowgreen; -moz-border-radius: 50px 50px 0 0; border-radius: 50px 50px 0 0; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-transform-origin: 0 100%; -moz-transform-origin: 0 100%; -ms-transform-origin: 0 100%; -o-transform-origin: 0 100%; transform-origin: 0 100%;&#125;.heart:after &#123; left: 10px; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); -webkit-transform-origin: 100% 100%; -moz-transform-origin: 100% 100%; -ms-transform-origin: 100% 100%; -o-transform-origin: 100% 100%; transform-origin: 100% 100%;&#125; 注：transform-origin设置旋转元素的基点，第一个值为X轴方向向右，第二个值为Y轴方向向下，所以0 100%为以左下角为基点旋转，100% 100%为以右下角为基点旋转当然也可以这么写123456789101112131415161718192021222324252627.heart&#123; position: relative; -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); transform: rotate(-45deg);&#125;.heart::after&#123; content: ''; -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); -webkit-transform: rotate(45deg); transform: rotate(90deg); position: absolute; top: 10px; left: 10px;&#125;.heart,.heart::after &#123; width: 40px; height: 60px; background: yellowgreen; -moz-border-radius: 20px 20px 0 0; -webkit-border-radius: 20px 20px 0 0; border-radius: 20px 20px 0 0;&#125; 旋转心形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051.heart &#123; position: relative; width: 80px; height: 80px; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-transform-origin: 50% 100%; -moz-transform-origin: 50% 100%; -ms-transform-origin: 50% 100%; -o-transform-origin: 50% 100%; transform-origin: 50% 100%; margin: 100px;&#125;.heart:before,.heart:after &#123; width: 40px; height: 60px; position: absolute; content: \"\"; left: 50px; top: 0; background: yellowgreen; -moz-border-radius: 50px 50px 0 0; border-radius: 50px 50px 0 0; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-transform-origin: 0 100%; -moz-transform-origin: 0 100%; -ms-transform-origin: 0 100%; -o-transform-origin: 0 100%; transform-origin: 0 100%;&#125;.heart:after &#123; left: 10px; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); -webkit-transform-origin: 100% 100%; -moz-transform-origin: 100% 100%; -ms-transform-origin: 100% 100%; -o-transform-origin: 100% 100%; transform-origin: 100% 100%;&#125; 其实就是在心形的基础上，让元素旋转一定的角度，即修改transform: rotate()中的值，注旋转时要设置旋转的基点，设置旋转基点前要给元素规定宽高，否则会以整个文档中心为基点进行旋转或者第二种画心形的方法中，直接修改.heart的transform: rotate()值即可这里我就列举了一个例子，想要什么角度的心形，自行修改旋转角度即可得到，就不再一一列举出来了 多角形五角星1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.star-five &#123; width: 0px; height: 0px; display: block; position: relative; color: #000; border-right: 100px solid transparent; border-bottom: 70px solid yellowgreen; border-left: 100px solid transparent; -moz-transform: rotate(36deg); -webkit-transform: rotate(36deg); -ms-transform: rotate(36deg); -o-transform: rotate(36deg); transform: rotate(36deg); margin: 100px;&#125;.star-five:before &#123; content: ''; width: 0; height: 0; display: block; position: absolute; top: -55px; left: -65px; border-bottom: 90px solid yellowgreen; border-left: 30px solid transparent; border-right: 30px solid transparent; -webkit-transform: rotate(-35deg); -moz-transform: rotate(-35deg); -ms-transform: rotate(-35deg); -o-transform: rotate(-35deg); transform: rotate(-35deg);&#125;.star-five:after &#123; content: ''; width: 0px; height: 0px; display: block; position: absolute; top: 3px; left: -106px; border-right: 100px solid transparent; border-bottom: 70px solid yellowgreen; border-left: 100px solid transparent; -webkit-transform: rotate(-72deg); -moz-transform: rotate(-72deg); -ms-transform: rotate(-72deg); -o-transform: rotate(-72deg); transform: rotate(-72deg);&#125; 其实就是两个等腰钝角三角形和一个等腰锐角三角形组合而成，这两个等腰钝角三角形都是由向上三角形（即只显示下边框）旋转各自的度数组成，然后再加上一个向上三角形就成了五角星，把这三个形状分为不同颜色，如下图就可以看出红色和绿色为两个钝角等腰三角形，蓝色的是一个锐角等腰三角形 六角星关于六角星，我们在六角星-上下-覆盖中已经提到过了，就是调整.triangle-tbottom-cover:after的top值即可得到六角星12345678910111213141516171819.star-six &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid yellowgreen; position: relative;&#125;.star-six:after &#123; content: \" \"; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid yellowgreen; position: absolute; top: 33px; left: -50px;&#125; 八角星十二角星多边形五边形六边形八边形##","tags":[{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"},{"name":"border","slug":"border","permalink":"http://yyeggs.com/tags/border/"}]},{"title":"PS保存成svg格式","date":"2018-10-22T09:34:31.000Z","path":"save_ps_svg/","text":"安装脚本下载save-ps-to-svg1.0.jsx脚本，并放到PS的安装目录/Presets/Scripts文件夹下，如图所示 绘制svg图形打开PS，使用形状工具绘图，（注：只有形状图层才可以保存为svg格式），并给该图层命名为xx.svg 保存为svg先保存psd格式文件，然后点击文件-&gt;脚本-&gt;Save as svg，即可在该psd同目录的文件夹下发现.svg格式的文件","tags":[{"name":"svg","slug":"svg","permalink":"http://yyeggs.com/tags/svg/"},{"name":"ps","slug":"ps","permalink":"http://yyeggs.com/tags/ps/"}]},{"title":"JS通用事件侦听器函数","date":"2018-10-22T07:11:11.000Z","path":"JS_addEventListener_event/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// JS通用事件侦听器函数 var EventUtil = &#123; // 页面加载完成之后执行 readyEvent: function (fn) &#123; if (document.addEventListener) &#123;//标准浏览器 document.addEventListener('DOMContentLoaded', function () &#123; document.removeEventListener('DOMContentLoaded', arguments.callee, false);//注销事件，避免反复触发 fn();// 执行函数 &#125;, false); &#125; else if (document.attachEvent) &#123;// IE浏览器 document.attachEvent('onreadystatechange', function () &#123; if (document.readyState == 'complete') &#123;//加载完成 document.detachEvent('onreadystatechange', arguments.callee); fn();//执行函数 &#125; &#125;); &#125; &#125;, /* *attachEvent可以使用匿名函数，但这样之后，detachEvent将无法卸载它。 *detachEvent所卸载的函数必须使用函数名。 */ //添加事件 addEvent:function(element,type,fn)&#123; if(element.addEventListener)&#123;// 标准浏览器 element.addEventListener(type,fn,false);//事件类型、需要执行的函数、是否捕获 &#125;else if(element.attachEvent)&#123;//IE浏览器 element.attachEvent('on'+type,fn); &#125;else&#123; element['on'+type]=fn;//DOM0 &#125; &#125;, //移除事件 removeEvent:function(element,type,fn)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,fn,false); &#125;else if(element.detachEvent)&#123; element.detachEvent('on'+type,fn); &#125;else&#123; element['on'+type]=null; &#125; &#125;, //阻止事件冒泡（主要是阻止冒泡，因为IE不支持事件捕获，用于停止事件在DOM层中传播，即进一步取消事件的捕获或者冒泡） stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation();//标准浏览器 &#125;else&#123; event.cancelBubble=ture;//IE &#125; &#125;, //阻止事件默认行为（如url跳转等） preventDefault:function(event)&#123; if(event.preventDefault)&#123; event.preventDefaule();//标准浏览器 &#125;else&#123; event.returnValue=false;//IE &#125; &#125;, //获取event对象的引用，获取事件的所有信息，确保随时能使用event getEvent:function(event)&#123; var event=event||window.event;//在DOM0级事件添加，event作为window对象的一个属性存在 &#125;, //获取事件目标 getTarget:function(event)&#123; return event.target||event.srcElement; &#125; &#125;;","tags":[{"name":"JS","slug":"JS","permalink":"http://yyeggs.com/tags/JS/"}]},{"title":"CSS之border详解","date":"2018-10-15T08:24:57.000Z","path":"CSS_border/","text":"border是用来规定元素边框的样式，有三种默认属性：border-width(边框宽度)、border-style(边框样式)、border-color(边框颜色)，这三种属性都可以分开来写，同时CSS3还新加入了border-radius(圆角度)和border-image(边框背景图)，下面我们就分别来了解一下各个样式属性的取值和说明等 border-width 边框宽度border-width分四个属性：border-top-widht、border-right-width、border-bottom-width、border-left-width取值： &lt;length&gt;:用长度值来定义边框的厚度，非负值 medium:定义默认厚度的边框，值为3px thin:定义比默认厚度细的边框，值为1px thick:定义比默认厚度粗的边框，值为5px说明：4个值：按上、右、下、左的顺序分别作用于四个边3个值：第一个值作用于上，第二个值作用于左右，第三个值作用于下2个值：第一个作用于上下，第二个值作用于左右1个值：同时作用于四个边 border-style 边框样式border-style分四个属性：border-top-style、border-right-style、border-bottom-style、border-left-style取值： none:无轮廓,该值情况下border-color将不起作用，border-width取值为0，除非边框轮廓为图像，即border-image hidden:隐藏边框,IE7及以下不支持 dotted:点状轮廓，IE6下显示为dashed效果 dashed:虚线轮廓 solid:实线轮廓 double:双线轮廓，两条单线与其间隔之和等于指定的border-width的值 groove:3D凹槽轮廓 ridge:3D凸槽轮廓 inset:3D凹边轮廓 outset:3D凸边轮廓说明：4个值：按上、右、下、左的顺序分别作用于四个边3个值：第一个值作用于上，第二个值作用于左右，第三个值作用于下2个值：第一个作用于上下，第二个值作用于左右1个值：同时作用于四个边 border-color 边框颜色border-color也跟前上面两个一样分上、右、下、左四个属性取值： &lt;color&gt;:指定颜色（transparent:透明）说明：4个值：按上、右、下、左的顺序分别作用于四个边3个值：第一个值作用于上，第二个值作用于左右，第三个值作用于下2个值：第一个作用于上下，第二个值作用于左右1个值：同时作用于四个边 border-radius 圆角度border-radius分四个属性：border-top-left-radius(左上角))、border-top-right-radius(右上角)、border-bottom-right-radius(右下角)、border-bottom-left-radius(左下角)取值：&lt;length&gt;:用长度设置对象的圆角半径长度，非负数&lt;percentage&gt;:用百分比设置对象的圆角半径长度说明：设置或检索对象使用圆角边框。提供2个参数，2个参数以“/”分隔，每个参数允许设置1~4个参数值，第1个参数表示水平半径，第2个参数表示垂直半径，若第2个参数省略，则默认等于第1个参数水平半径：4个值：按top-left(左上角)、top-right(右上角)、bottom-right(右下角)、bottom-left(左下角)顺序分别作用于四个角3个值：第一个值作用于top-left(左上角)，第二个值作用于top-right(右上角)和bottom-left(左下角)，第三个值作用于bottom-right(右下角)2个值：第一个值作用于top-left(左上角)和bottom-right(右下角)，第二个值作用于top-right(右上角)和bottom-left(左下角)1个值：同时作用于全部4个角注：如果想让2个值的时候表示相邻的两个角而不是对角，可以这样写：border-radius:&lt;length&gt;/&lt;length&gt;，其中第一个值表示左上角和右上角，第二个值表示右下角和左下角垂直半径同上 border-image 边框背景图border-image分五个属性：border-image-source、border-image-slice、border-image-width、border-image-outset、border-image-repeat取值：border-image-source：设置或检索对象的边框是否用图像定义样式或图像来源路径border-image-slice：设置或检索对象的边框背景图的分割方式border-image-width：设置或检索对象的边框厚度border-image-outset：设置或检索对象的边框背景图的扩展border-image-repeat：设置或检索对象的边框图像的平铺方式说明：当此属性不生效或图片未加载成功时，border-style就会生效 box-shadow 边框阴影取值：none:无阴影&lt;length&gt;：第1个长度值–阴影水平偏移值，方向：右&lt;length&gt;：第2个长度值–阴影垂直偏移值，方向：下&lt;length&gt;：第3个长度值–阴影模糊值，非负数，可选&lt;length&gt;：第4个长度值–阴影外延值，可为负，可选&lt;color&gt;：阴影颜色inset：阴影类型为内阴影，（当无此值时，默认为外阴影）说明：可以设置多组效果，每组以逗号分隔，应用顺序与上面相同 总结本篇主要针对CSS的border属性进行详解，其实我写这篇博客的主要目的是为后面的用border属性写各种对话气泡和各种图形做铺垫，感兴趣的话可以多多关注哦！","tags":[{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"},{"name":"border","slug":"border","permalink":"http://yyeggs.com/tags/border/"}]},{"title":"多栏布局（二）--上下栏布局","date":"2018-10-10T07:46:38.000Z","path":"Multi_Column_Layout_tb/","text":"1 上固定，下自适应1.1 absolute 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; height: 100px; background: red; &#125; .bottom &#123; position: absolute; top: 100px; bottom: 0; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p&#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt; 1.2 absolute-fixed 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; height: 100px; background: red; &#125; .bottom &#123; position: fixed; top: 100px; bottom: 0; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p&#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt; 1.3 fixed-absolute 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: fixed; top: 0; height: 100px; background: red; &#125; .bottom &#123; position: absolute; top: 100px; bottom: 0; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p&#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt; 其实就是用定位实现，方案1全是绝对定位absolute，方案2和方案3就是一个是绝对定位absolute另一个是固定定位fixed；后面的下固定，上自适应和上下自适应，中间自适应也是相同的道理。是不是很简单 2 下固定，上自适应2.1 absolute 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; bottom: 100px; overflow: auto; background: yellowgreen; &#125; .bottom &#123; position: absolute; bottom: 0; height: 100px; background: red; &#125; /* 查看滚动效果 */ div p&#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 2.2 absolute-fixed 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: fixed; top: 0; bottom: 100px; overflow: auto; background: yellowgreen; &#125; .bottom &#123; position: absolute; bottom: 0; height: 100px; background: red; &#125; /* 查看滚动效果 */ div p &#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 2.3 fixed-absolute 解决方案1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; bottom: 100px; overflow: auto; background: yellowgreen; &#125; .bottom &#123; position: fixed; bottom: 0; height: 100px; background: red; &#125; /* 查看滚动效果 */ div p &#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"top\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 3 上下固定，中间自适应3.1 absolute 解决方案12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; height: 100px; background: yellow; &#125; .bottom &#123; position: absolute; bottom: 0; height: 100px; background: red; &#125; .center&#123; position: absolute; top: 100px; bottom: 100px; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p &#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"center\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 3.2 absolute-fixed 解决方案12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; height: 100px; background: yellow; &#125; .bottom &#123; position: absolute; bottom: 0; height: 100px; background: red; &#125; .center&#123; position: fixed; top: 100px; bottom: 100px; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p &#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"center\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 3.3 fixed-absolute 解决方案12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: fixed; top: 0; height: 100px; background: yellow; &#125; .bottom &#123; position: fixed; bottom: 0; height: 100px; background: red; &#125; .center&#123; position: absolute; top: 100px; bottom: 100px; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p &#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"center\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 需要注意的一点就是，这种布局，一般都会设置html和body高度100%，并且溢出隐藏overflow:hidden;而自适应的用来放内容的那一部分设置溢出自适应overflow:auto;这样滚动条就会出现在这一部分，而不是整个页面","tags":[{"name":"html","slug":"html","permalink":"http://yyeggs.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"}]},{"title":"多栏布局（一）-- 左右栏布局","date":"2018-10-03T10:58:47.000Z","path":"Multi_Column_Layout_lr/","text":"1 左固定，右自适应1.1 浮动解决方案123456789101112131415161718192021222324252627282930&lt;style&gt; html,body&#123; margin: 0; padding:0; &#125; div&#123; min-height: 100px; &#125; .left &#123; float: left; width: 300px; background: red; &#125; .right &#123; margin-left: 300px; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 注：上面.right 的 margin-left 属性可以用 overflow:hidden 来替代（让.right 开启 BFC）否则当右侧高度过大时，会出现如下效果： 特点：两栏高度不一致优点：兼容性好缺点：浮动元素过多会导致页面结构复杂，并且要清除浮动，否则会导致页面混乱 1.2 定位解决方案1.2.1 定位解决方案 1123456789101112131415161718192021222324252627282930313233&lt;style&gt; html,body&#123; margin: 0; padding:0; &#125; div&#123; min-height: 100px; &#125; .wrap&#123; position: relative; &#125; .left &#123; position: absolute; width: 300px; background: red; &#125; .right &#123; margin-left: 300px; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;定位解决方案1 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1.2.2 定位解决方案 212345678910111213141516171819202122232425262728293031323334353637383940&lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; position: relative; &#125; .left &#123; position: absolute; width: 300px; background: red; &#125; .right &#123; position: absolute; left: 300px; right: 0; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;定位解决方案2 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 特点：两栏高度不一致优点：兼容性好缺点：脱离文档流，增加页面结构的复杂程度 1.3 table 解决方案123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: table; width: 100%; &#125; .left &#123; display: table-cell; width: 300px; background: red; &#125; .right &#123; display: table-cell; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;table解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致 1.4 flex 解决方案12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: flex; &#125; .left &#123; width: 300px; background: red; &#125; .right &#123; flex: 1; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;flex解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致优点：CSS3 新属性，实现简单缺点：兼容性差 1.5 grid 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: grid; grid-template-columns: 300px auto; &#125; .left &#123; background: red; &#125; .right &#123; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;grid解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致优点：CSS3新属性，实现简单缺点：兼容性差 2 右固定，左自适应2.1 浮动解决方案123456789101112131415161718192021222324252627282930&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .left &#123; background: yellowgreen; margin-right: 300px; &#125; .right &#123; float: right; width: 300px; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"right\"&gt;&lt;/div&gt; 注：上面.left 的 margin-right 属性可以用 overflow:hidden 来替代（让.left 开启 BFC） 在页面结构上，必须让固定的元素位于自适应的元素之前，否则若自适应的元素在前，因为其为块级元素，盒模型将会占一整行的宽度，这样固定的元素就会被挤到下面，页面结构就会混乱，如下图；而固定的元素在前，因为其设置了浮动，所以脱离了文档流，且z-index级别比文档流高，所以会压在自适应的元素之上特点：两栏高度不一致优点：兼容性好缺点：浮动元素过多会导致页面结构复杂，并且要清除浮动，否则会导致页面混乱 2.2 定位解决方案2.2.1 定位解决方案 11234567891011121314151617181920212223242526272829303132333435&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; position: relative; &#125; .left &#123; margin-right: 300px; background: yellowgreen; &#125; .right &#123; position: absolute; right: 0; top:0; width: 300px; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;定位解决方案1 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 注：定位解决方案1中，在页面结构上，固定的右侧栏也必须在自适应的左侧栏之前，理由同上，其左侧栏.left同样没有脱离文档流 2.2.2 定位解决方案 2123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; position: relative; &#125; .left &#123; position: absolute; left: 0; right: 300px;; background: yellowgreen; &#125; .right &#123; position: absolute; right: 0; width: 300px; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;定位解决方案2 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 特点：两栏高度不一致优点：兼容性好缺点：脱离文档流，增加页面结构的复杂程度 2.3 table 解决方案12345678910111213141516171819202122232425262728293031323334&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: table; width: 100%; &#125; .left &#123; display: table-cell; background: yellowgreen; &#125; .right &#123; display: table-cell; width: 300px; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致 2.4 flex 解决方案1234567891011121314151617181920212223242526272829303132&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: flex; &#125; .left &#123; flex: 1; background: yellowgreen; &#125; .right &#123; width: 300px; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致优点：CSS3 新属性，实现简单缺点：兼容性差 2.5 grid 解决方案12345678910111213141516171819202122232425262728293031&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: grid; grid-template-columns: auto 300px; &#125; .left &#123; background: yellowgreen; &#125; .right &#123; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致优点：CSS3新属性，实现简单缺点：兼容性差 3 左右固定，中间自适应3.1 浮动解决方案12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .left &#123; float: left; width: 300px; background: yellow; &#125; .right &#123; float: right; width: 300px; background: red; &#125; .center &#123; margin-left: 300px; margin-right: 300px; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 注：上面.center 的 margin 属性可以用 overflow:hidden 来替代（让.center 开启 BFC） 在页面结构上，在页面结构上，固定的两侧栏在前，自适应的中间栏在后，原因见上面右固定，左自适应的浮动解决方案特点：三栏高度不一致优点：兼容性好缺点：浮动元素过多会导致页面结构复杂，并且要清除浮动，否则会导致页面混乱 3.2 定位解决方案3.2.1 定位解决方案1123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; position: relative; &#125; .left &#123; position: absolute; left: 0; width: 300px; background: yellow; &#125; .right &#123; position: absolute; right: 0; width: 300px; background: red; &#125; .center &#123; margin-left: 300px; margin-right: 300px; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;定位解决方案1 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 注：定位解决方案1中，在页面结构上，固定的两侧栏在前，自适应的中间栏在后，原因见上面右固定，左自适应的浮动解决方案 3.2.2 定位解决方案212345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; position: relative; &#125; .left &#123; position: absolute; left: 0; width: 300px; background: yellow; &#125; .right &#123; position: absolute; right: 0; width: 300px; background: red; &#125; .center &#123; position: absolute; left: 300px; right: 300px; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：三栏高度不一致优点：兼容性好缺点：脱离文档流，增加页面结构的复杂程度 3.3 table 解决方案12345678910111213141516171819202122232425262728293031323334353637383940&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: table; width: 100%; &#125; .left &#123; display: table-cell; width: 300px; background: yellow; &#125; .right &#123; display: table-cell; width: 300px; background: red; &#125; .center &#123; display: table-cell; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：三栏高度一致 3.4 flex 解决方案12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: flex; &#125; .left &#123; width: 300px; background: yellow; &#125; .right &#123; width: 300px; background: red; &#125; .center &#123; flex: 1; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：三栏高度一致优点：CSS3 新属性，实现简单缺点：兼容性差 3.5 grid 解决方案1234567891011121314151617181920212223242526272829303132333435&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: grid; grid-template-columns: 300px auto 300px; &#125; .left &#123; background: yellow; &#125; .right &#123; background: red; &#125; .center &#123; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：三栏高度一致优点：CSS3新属性，实现简单缺点：兼容性差 4 总结其实不管是谁固定，谁自适应，可以看到都是通过浮动、定位、table、flex、grid这5种方法实现的，只要掌握好这5种方法，可以应对以上三种布局方式","tags":[{"name":"html","slug":"html","permalink":"http://yyeggs.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"}]},{"title":"居中问题（三） -- 水平垂直居中","date":"2018-09-11T12:13:38.000Z","path":"Center_Horizontal_Vertical/","text":"鉴于实际需求，这里只列举了块级元素内的块级元素水平垂直居中，如果你想要实现块级元素内的行内元素或类行内元素居中，请参考前两篇的水平居中和垂直居中的博客 1 水平垂直居中1.1 margin1234567891011121314151617181920212223&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; border: 1px solid transparent; background: paleturquoise; &#125; .in &#123; width: 100px; height: 100px; margin-top: 50px; margin-left: 50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：.in的margin-left值为(.wrap的宽度-.in的宽度)/2；.in的margin-top值为(.wrap的高度-.in的高度)/2；值得注意的是我在.wrap上添加了一个border: 1px solid transparent;属性，目的是为了解决边距重叠问题，关于边距重叠问题，我后续也会专门写一篇博客来详细介绍，有兴趣的小伙伴可以继续关注哦！ 优点：最简单的实现方式，兼容各种浏览器缺点：可扩展性低，内盒子的宽高必须固定，且每当改变内外盒子的宽高，margin值都要重新计算 1.2 定位 position1234567891011121314151617181920212223242526&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：最常用的实现方式，兼容性好，可以同时实现水平和垂直居中缺点：内盒子的宽高必须固定 1.3 定位 position–margin12345678910111213141516171819202122232425262728&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; height: 100px; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：定位方式的一种，我们都知道当定位的元素同时设置了top、right、bottom和left值时只有top和left起作用，但当加上margin:auto这点睛之笔后，你会发现这四个值都会起作用，而当这四个值都是0时就实现了我们现在的水平垂直居中了，怎么样？神不神奇 优点：兼容性好，可以同时实现水平垂直居中，且宽度无须固定缺点：高度必须固定，否则将占父元素的100% 1.4 定位position结合transform1.4.1 absolute–transform1234567891011121314151617181920212223242526&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; /* height: 100px;*/ position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：弥补了1.2中的缺点，内盒子宽高可以不固定，当内盒子宽高固定时，translate()括号中的值为负的内盒子宽/高的二分之一即可，即相当于1.2中的margin-left/top，而不论内盒子宽高是否固定，translate()括号中的值都可以是两个-50%。注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d;具体关于CSS3的动画属性，我后续也会专门写一篇博客进行介绍，有兴趣的小伙伴，可以一起讨论讨论哦 优点：实现简单，宽高无须固定缺点：transform是CSS3的新属性，所以兼容性比较差 1.4.2 relative–transform12345678910111213141516171819202122232425&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; /* height: 100px;*/ position: relative; top: 50%; left: 50%; transform: translate(-50%,-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：这个方法与1.4.1极相似，不同之处在于，此法外盒子不定位，直接给内盒子采取相对定位relative，但一般使用率比较低注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d; 1.5 table-cell123456789101112131415161718192021222324&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; display: table-cell; vertical-align: middle; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; /* height: 100px;*/ margin: 0 auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：实现简单，内盒子宽高无须固定缺点：table-cell会跟浮动、定位等属性相互冲突，并且不能设置margin属性 1.6 flex1.6.1 align-items123456789101112131415161718192021222324&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; /* height: 100px;*/ background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：justify-content:center;意为flex主轴方向对齐方式：居中，而align-items: center;意为交叉轴方向对齐方式：居中。主轴方向flex-direction默认为row即横向，则交叉轴即为纵向，也就是垂直方向关于flex可以参考我的博客 优点：实现简单，内盒子宽高无须固定缺点：flex为CSS3新属性，兼容性差，且flex内的元素float、clear、vertical-align等样式全部失效 1.6.2 align-self123456789101112131415161718192021222324&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; display: flex; justify-content: center; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; /* height: 100px;*/ align-self: center; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：这个方法跟上一个很相似，唯一不一样的地方就在于上一个方法用align-items属性，而这个方法用的是align-self属性。简单说一下两个属性的区别：align-items属性是容器即外盒子的属性，意为容器内所有元素的交叉轴对齐方式；而align-self属性是内元素属性，意为本元素的交叉轴对齐方式 1.7 calc()12345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; border: 1px solid transparent; background: paleturquoise; &#125; .in &#123; width: 100px; height: 100px; margin: calc(50% - 50px) auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：前面那个50%取值是父元素高度的50%，后面那个50px取值是本元素的高的一半，其实原理跟1.1的margin是相同的注：不要质疑calc()就是一个CSS3属性，是用来指定长度的，比如可以给元素的width、height、border、margin、padding、font-size等属性设置动态值，但一定要注意calc()括号中的运算符前后一定要有空格！运算符前后一定要有空格！运算符前后一定要有空格！（重要的事情说三遍） 优点：当页面结构复杂无法用其它方式实现水平垂直居中时，你会非常喜欢这个属性的缺点：CSS3新属性，兼容性还不是很好，而且在css中进行计算会降低页面性能 2 总结关于我所了解的水平居中、垂直居中、水平垂直居中的各种方法到这里就介绍完毕了，如果小伙伴们还有其它方法，或者在具体的实践中遇到任何问题，都欢迎大家在评论区积极讨论，我也会一直关注的哦✌","tags":[{"name":"html","slug":"html","permalink":"http://yyeggs.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"}]},{"title":"居中问题（二） -- 垂直居中","date":"2018-09-01T07:02:16.000Z","path":"Center_Vertical/","text":"1 行内元素内容居中12345678910111213&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; span&#123; padding: 5px 8px; float: left; background: plum; &#125;&lt;/style&gt;&lt;span&gt;请叫我小仙女&lt;/span&gt; 说明：大多数行内元素不能设置宽高，只能由内容撑起，而若要实现上下左右有空隙则需设置padding，但是行内元素的padding只对左、右、下起作用，margin只对左、右起作用，所以对于行内元素若想让上述属性起作用，则需设置浮动或定位，而若要垂直方向居中则设置padding-top=padding-bottom即可 优点：简单、常用，可同时实现水平垂直居中，兼容性好缺点：需要设置浮动或定位来辅助实现 2 块级元素中的行内元素或类行内元素居中2.1 line-height1234567891011121314151617181920&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; line-height: 200px; background: paleturquoise; &#125; span &#123; background: plum; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;span&gt;请叫我小仙女&lt;/span&gt; &lt;img src=\"images/eg_cute.gif\" alt=\"\"&gt;&lt;/div&gt; 说明：外盒子设置line-height=height即可 优点：简单、常用，兼容性好缺点：若需要居中的内容为多行则不适用 2.2 vertical-align12345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; display: table-cell; vertical-align: middle; background: paleturquoise; &#125; span &#123; background: plum; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"wrap\"&gt; &lt;span&gt;请叫我小仙女请叫我小仙女请叫我小仙女&lt;/span&gt; &lt;/div&gt; 说明：在没有其它属性辅助的情况下，只有table-cell属性的元素才可以使用vertical-align属性 优点：可同时适用于单行和多行内容缺点：实现条件苛刻 2.3 flex1234567891011121314151617181920&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; display: flex; align-items: center; background: paleturquoise; &#125; span &#123; background: plum; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;span&gt;请叫我小仙女小仙女小仙女小仙女&lt;/span&gt;&lt;/div&gt; 优点：可同时适用于单行和多行内容缺点：CSS3新属性，兼容性差 3 块级元素3.1 margin123456789101112131415161718192021&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; border: 1px solid transparent; background: paleturquoise; &#125; .in &#123; height: 100px; margin-top: 50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：.in的margin-top值为(.wrap的高度-.in的高度)/2；值得注意的是我在.wrap上添加了一个border: 1px solid transparent;属性，目的是为了解决边距重叠问题，关于边距重叠问题，我后续也会专门写一篇博客来详细介绍，有兴趣的小伙伴可以继续关注哦！ 优点：最简单的实现方式，兼容各种浏览器缺点：可扩展性低，内盒子的高度必须固定，且每当改变内外盒子的高度，margin-top的值都要重新计算 3.2 定位position1234567891011121314151617181920212223&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in &#123; height: 100px; position: absolute; top: 50%; margin-top: -50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：最常用的实现方式，兼容性好，可以在此基础上以同样方法添加left和margin-left实现水平垂直居中缺点：内盒子的高度必须固定 3.3 定位position结合transform3.3.1 absolute–transform1234567891011121314151617181920212223&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in &#123; /* height: 100px; */ position: absolute; top: 50%; transform: translateY(-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d;优点：弥补了3.2中的缺点，内盒子高度可以不固定，当内盒子高度固定时，translateY()括号中的值为负的内盒子高的二分之一即可，即相当于3.2中的margin-top，而不论内盒子高度是否固定，translateY()括号中的值都可以是-50%缺点：transform是CSS3的新属性，所以兼容性比较差 3.3.2 relative–transform12345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in &#123; height: 100px; position: relative; top: 50%; transform: translateY(-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：这个方法与3.3.1极相似，不同之处在于，此法外盒子不定位，直接给内盒子采取相对定位relative，但一般不会这样使用，都是采用上面那种方法注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d; 3.4 :before结合inline-block结合vertical-align1234567891011121314151617181920212223242526&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; background: paleturquoise; &#125; .wrap::before&#123; content:\"\"; display:inline-block; height:100%; vertical-align:middle; &#125; .in &#123; display: inline-block; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 缺点：实现起来比较麻烦，所以很少用 3.5 flex123456789101112131415161718192021&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; display: flex; align-items: center; background: paleturquoise; &#125; .in &#123; /* height: 100px; */ background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：align-items:center;意为交叉轴方向对齐方式：居中。主轴方向flex-direction默认为row即横向，则交叉轴即为纵向，也就是垂直方向关于flex可以参考我的博客 优点：实现简单，内盒子高度无须固定缺点：flex为CSS3新属性，兼容性差，且flex内的元素float、clear、vertical-align等样式全部失效 3.6 增加节点1234567891011121314151617181920212223&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; background: paleturquoise; &#125; .hide&#123; height: 50px; &#125; .in &#123; height: 100px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"hide\"&gt;&lt;/div&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：在内盒子前添加一个元素，并且设置高度为内外盒子高度差的二分之一，宽度默认100%即可,其实这种方法跟3.1原理是相同的，此处.hide的位置即为3.1中margin-top所占据的位置 优点：请原谅我从宏观上看并没有发现此方法的优点，但不代表这种方法没有用，或许在某些复杂或奇怪的页面结构中，其它方法都不适用，只能采用这种方法呢缺点：需要增加元素节点，且内盒子高度必须固定 4 总结关于垂直居中的方法就总结到这里了，如果小伙伴们还有其它方法，或者在具体的实践中遇到任何问题，都欢迎大家在评论区积极讨论，我也会一直关注的哦✌","tags":[{"name":"html","slug":"html","permalink":"http://yyeggs.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"}]},{"title":"居中问题（一） -- 水平居中","date":"2018-08-16T03:22:40.000Z","path":"Center_Horizontal/","text":"对于行内元素的内容居中，因为行内元素一般都不能设置宽高，而是由内容撑起的，可以设置padding值，所以这里的居中问题考虑的是块级元素内的元素水平居中，而不考虑行内元素内的元素或内容居中 1 行内或类行内元素（比如图片、文本、链接等）居中12345678910111213141516&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; text-align: center; background: paleturquoise; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;span&gt;请叫我小仙女&lt;/span&gt;&lt;/div&gt; 块级父容器设置text-align: center; 2 块级元素居中2.1 margin1234567891011121314151617181920&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in&#123; width: 100px; margin-left: 50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：.in的margin-left值为(.wrap的宽度-.in的宽度)/2 优点：最简单的实现方式，兼容各种浏览器缺点：可扩展性低，内盒子的宽度必须固定，且每当改变内外盒子的宽度，margin-left的值都要重新计算 2.2 margin–auto123456789101112131415161718192021&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; margin: 0 auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：最简单、常用的实现方式，兼容各种浏览器，并且当内盒子的宽度不固定时（例如上面width:fit-content（宽度收缩到内容））也同样适用缺点：此属性只能实现水平居中，不能像定位属性那样可以同时实现水平垂直居中 2.3 定位position1234567891011121314151617181920212223&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in&#123; width: 100px; position: absolute; left: 50%; margin-left: -50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：最常用的实现方式，兼容性好，可以在此基础上以同样方法添加top和margin-top实现水平垂直居中缺点：内盒子的宽度必须固定 2.4 定位position结合transform2.4.1 absolute–transform123456789101112131415161718192021222324&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; position: absolute; left: 50%; transform: translateX(-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d;优点：弥补了2.3中的缺点，内盒子宽度可以不固定，当内盒子宽度固定时，translateX()括号中的值为负的内盒子宽的二分之一即可，即相当于2.3中的margin-left，而不论内盒子宽度是否固定，translateX()括号中的值都可以是-50%缺点：transform是CSS3的新属性，所以兼容性比较差 2.4.2 relative–transform123456789101112131415161718192021222324&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; position: relative; left: 50%; transform: translateX(-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我仙女&lt;/div&gt;&lt;/div&gt;&lt;div class=\"wrap\"&gt;&lt;/div&gt; 说明：这个方法与2.4.1极相似，不同之处在于，此法外盒子不定位，直接给内盒子采取相对定位relative，但一般不会这样使用，都是采用上面那种方法注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d; 2.5 table-cell/inline-block2.5.1 table-cell12345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; display: table-cell; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; margin: 0 auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：实现简单，内盒子宽度无须固定缺点：table-cell会跟浮动、定位等属性相互冲突，并且不能设置margin属性 2.5.2 inline-block 112345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; display: inline-block; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; margin: 0 auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 2.5.3 inline-block 212345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; text-align: center; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; display: inline-block; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我仙女&lt;/div&gt;&lt;/div&gt; 说明：把内盒子设成行内块元素，使用1中行内元素的居中方式 优点：内盒子宽度无须固定 2.6 flex12345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; display: flex; justify-content: center; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我仙女&lt;/div&gt;&lt;/div&gt; 说明：justify-content:center;意为flex主轴方向对齐方式：居中。主轴方向flex-direction默认为row即横向注：如果内盒子不设高度，外盒子使用flex属性后，会出现如下现象因为外盒子没有设置垂直方向上的对齐方式align-items，而它的默认值是stretch即铺满容器，所以就出现了内盒子高度等于外盒子高度，所以未避免这种情况，可以根据需求设置align-items对齐方式，此处可添加align-items:flex-start;即顶端对齐关于flex可以参考我的博客 优点：实现简单，内盒子宽度无须固定缺点：flex为CSS3新属性，兼容性差，且flex内的元素float、clear、vertical-align等样式全部失效 2.7 增加节点1234567891011121314151617181920212223242526&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in&#123; width: 100px; float: left; background: peachpuff; &#125; .hide&#123; width: 50px; height: 1px; float: left; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"hide\"&gt;&lt;/div&gt; &lt;div class=\"in\"&gt;请叫我仙女&lt;/div&gt;&lt;/div&gt; 说明：在内盒子前添加一个元素，并且设置宽为内外盒子宽度差的二分之一，高为1px,两个元素都设置float,其实这种方法跟2.1原理是相同的，此处.hide的位置即为2.1中margin-left所占据的位置 优点：请原谅我从宏观上看并没有发现此方法的优点，但不代表这种方法没有用，或许在某些复杂或奇怪的页面结构中，其它方法都不适用，只能采用这种方法呢缺点：需要增加元素节点，并且用到浮动属性增加页面复杂度，且内盒子宽度固定 3 总结关于水平居中的方法就总结到这里了，如果小伙伴们还有其它方法，或者在具体的实践中遇到任何问题，都欢迎大家在评论区积极讨论，我也会一直关注的哦✌","tags":[{"name":"html","slug":"html","permalink":"http://yyeggs.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"}]}]