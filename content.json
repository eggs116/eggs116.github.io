[{"title":"轮播图（四）--手风琴轮播图","date":"2019-03-23T07:22:20.000Z","path":"slideshow_accordion/","text":"手风琴轮播图就是我在轮播图系列一中提起过的，那个让我感兴趣的轮播图，也是因为它再次勾起了我要整理轮播图系列的想法。手风琴轮播图并不复杂，好像也不是很常见，而且它也不是自动轮播的（这一方面，我之后会尝试看自动轮播的手风琴轮播图效果，这里暂且先不提）。 核心思想及问题通过控制图片的展示宽度来实现轮播图效果 完整代码CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445html,body &#123; margin: 0; padding: 0;&#125;ul,ol &#123; list-style: none; margin: 0; padding: 0;&#125;.wrap &#123; width: 1200px; height: 260px; padding: 5px; border: 1px solid #ccc; margin: 100px auto; position: relative;&#125;.slide &#123; width: 1200px; height: 260px; position: relative; overflow: hidden;&#125;ul &#123; width: 1200px; position: absolute; left: 0;&#125;ul li &#123; float: left; width: 133px; height: 260px; background-position:left;&#125;ul li:first-child&#123; width: 400px; margin: 0 1px 0 0;&#125;img &#123; width: 400px; height: 260px; vertical-align: middle;&#125; 可以通过li的“background-position: center;”样式来控制默认展示的图片位置，并控制鼠标经过的时候图片是向两侧展开还是向一侧展开。当设置这个样式的时候，默认显示图片中间区域，鼠标经过效果为向两侧展开；若不设置此样式（即默认“background-position: left;”）,默认显示图片左侧区域，鼠标经过效果为单侧展开。HTML123&lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;div class=\"slide\" id=\"slide\"&gt;&lt;/div&gt;&lt;/div&gt; 在前面的轮播图中，我都是直接在html中放入图片，而这里没有在html中插入图片而是用JS控制插入图片，之前的轮播图其实也都可以改成这种方式，这种做法在以后的维护中更方便。JS12345678910111213141516171819202122232425262728293031var slide = document.getElementById('slide');var ul=document.createElement('ul');for(var i=0;i&lt;7;i++)&#123;//在ul中插入li并设置背景图 var li=document.createElement('li'); li.style.backgroundImage='url(img/'+(i+1)+'.jpg)'; ul.append(li);&#125;slide.append(ul);//将ul插入页面var lis=ul.children;var lis_len=lis.length;//遍历li,所有li都有鼠标经过事件for(var i=0;i&lt;lis_len;i++)&#123; lis[i].index=i;//获得序号 lis[i].addEventListener('mouseover',function()&#123; var that=this.index; for(var j=0;j&lt;lis_len;j++)&#123;//遍历，所有li外边界为0,宽度为收缩状 lis[j].style.margin=0; moveAnimation(lis[j],&#123;width:133&#125;); &#125; // 判断，若是第一张图右侧有外边距，最后一张左侧有边距，否则两边都有边距 if(that===0)&#123; this.style.margin=\"0 1px 0 0\"; &#125;else if(that===lis_len-1)&#123; this.style.margin=\"0 0 0 1px\"; &#125;else&#123; this.style.margin=\"0 1px\"; &#125; this.style.margin=\"0 px\"; moveAnimation(this,&#123;width:400&#125;); &#125;);&#125; 注：同样，这里的JS代码也用到了moveAnimation函数，所以也要像轮播图（二）中的例子一样引入moveAnimation函数或引入其封装的moveAnimation.js 总结：手风琴轮播图相对于其它的轮播图是比较新颖的，而且用纯CSS也可以实现，今天先只介绍用JS实现的，感兴趣的话可以关注我后续的博客，用纯CSS来实现手风琴轮播图。到这里轮播图系列就整理完毕了，这一系列我分类四篇来整理的，一共包括七种不同的轮播图，分别为：平滑无缝滚动轮播图、无缝切换轮播图（有箭头，无序号）、无缝切换轮播图（无箭头，有序号）、无缝切换轮播图（有箭头，有序号）、 经典网易轮播图、旋转木马轮播图以及今天的手风琴轮播图，希望可以帮到你。本篇文章是由二蛋的前端博客：http://yyeggs.com/slideshow_accordion/ 整理。整理不易，转载请注明","tags":[{"name":"JS","slug":"JS","permalink":"http://yyeggs.com/tags/JS/"},{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"}]},{"title":"轮播图（三）--旋转木马轮播图","date":"2019-03-23T07:22:20.000Z","path":"slideshow_rotation/","text":"继平滑无缝滚动轮播图和4中无缝切换轮播图之后，我们再介绍一种旋转木马轮播图，这种轮播图看上去比较炫，多存在于电商网站中 核心思想及问题其实旋转木马轮播图看上去最为复杂，但只要搞清楚它的核心思想，就发现其实很简单。旋转木马轮播图的核心思想是：针对每个视觉位置给定一个位置信息（对象），这些位置信息（对象），组成一个数组（我称其为位置数组，数组中的每一项都是一个对象）。当轮播的时候，图片顺序固定变，改变位置数组中各值的顺序。如下是初始化时图像与位置数组的对应关系，其中位置数组中的“4号位”始终是当前的显示位，也就是可视区的位置，两侧分别为左1，左2，左3，以及右1，右2，右3初始化时默认显示第四张图片，也就是④，当自动轮播或点击右箭头（下一张）时，显示第五张图片，也就是⑤：图片顺序不变，位置数组顺序改变—删除最后一项并把删除的最后一项添加为第一项以此类推当点击左箭头（上一张）时，就以上面结果为例，假如当前显示的是第六张图片，也就是⑥，要显示上一张图片即第五张图片，也就是⑤：图片顺序依然不变，位置数组顺序改变—删除第一项并把删除的第一项添加为最后一项 完整代码CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354html,body &#123; margin: 0; padding: 0;&#125;ul,ol &#123; list-style: none; margin: 0; padding: 0;&#125;.wrap &#123; width: 600px; margin: 200px auto; position: relative;&#125;.slide &#123; height: 260px; position: relative;&#125;ul li &#123; position: absolute; left: 100px;&#125;img &#123; width: 100%; vertical-align: middle;&#125;.arr &#123; width: 600px; height: 50px; position: absolute; top: 50%; margin-top: -25px; opacity: 1; z-index: 10;&#125;.arr span &#123; width: 50px; line-height: 50px; text-align: center; font-family: \"黑体\"; font-size: 30px; background-color: rgba(0, 0, 0, 0.8); color: #ccc; position: absolute; cursor: pointer;&#125;.arr .pre &#123; left: 0px;&#125;.arr .next &#123; right: 0px;&#125; HTML1234567891011121314151617&lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;div class=\"slide\" id=\"slide\"&gt; &lt;ul id=\"ul\"&gt; &lt;li&gt;&lt;img src=\"img/1.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/3.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/4.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/5.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/6.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/7.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"arr\" id=\"arr\"&gt; &lt;span class=\"pre\" id=\"pre\"&gt;&lt;&lt;/span&gt; &lt;span class=\"next\" id=\"next\"&gt;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; JS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var wrap = document.getElementById('wrap');var ul=document.getElementById('ul');var lis=ul.children;var lis_len=lis.length;var arr=document.getElementById('arr');var json_arr=[//每条数据（每条数据都代表一个位置）都控制着一张图片的对应样式，由上至下，依次是第1~7张图片，切换时图片由上至下依然是第1~7张图片，而数组中的数据位置改变，从而实现图片切换效果 &#123;width:200,top:-70,left:60,opacity:40,z:1&#125;,//注此处opacity为0~100间的值，而非0~1 &#123;width:250,top:-50,left:30,opacity:60,z:2&#125;, &#123;width:300,top:-30,left:0,opacity:80,z:3&#125;, &#123;width:400,top:0,left:100,opacity:100,z:4&#125;, &#123;width:300,top:-30,left:300,opacity:80,z:3&#125;, &#123;width:250,top:-50,left:320,opacity:60,z:2&#125;, &#123;width:200,top:-70,left:340,opacity:40,z:1&#125;]var click_btn=true;//节流，防止不间断点击按钮，当click_btn为true时才可以执行点击事件togglePic();//执行一次togglePic函数--按最初状态布局图片//自动执行动画即每间隔一定时间执行一次nextAnimate函数var timer=null;timer=setInterval(nextAnimate,2000);//通过event事件，判断触发事件的元素的id来确定点击的是next还是pre来执行对应事件arr.addEventListener('click',function(e)&#123; var e=e||window.e; var target=e.target||e.srcElement; if(target.id==='next'&amp;&amp;click_btn)&#123; click_btn=false; //动画未执行完之前，click_btn赋值为false禁止下次点击事件执行 nextAnimate(); &#125;else if(target.id==='pre'&amp;&amp;click_btn)&#123; click_btn=false; preAnimate(); &#125;&#125;);//鼠标经过arr出现，自动执行动画暂停，wrap.addEventListener('mouseover',function()&#123; arr.style.opacity=1; clearInterval(timer);&#125;)//鼠标移除继续从当前图片执行动画wrap.addEventListener('mouseout',function()&#123; arr.style.opacity=0; timer=setInterval(nextAnimate,2000);&#125;) //nextAnimate函数function nextAnimate()&#123; //数组中第1个json对象永远都对应第一张图片，一次类推，通过调整数组中json对象的顺序来控制图片位置（注每个json对象都对应一个固定的位置） json_arr.unshift(json_arr.pop());//pop()删除数组的最后一个元素并返回此元素，unshift()在数组首尾插入元素 togglePic(); &#125;//preAnimate 函数function preAnimate()&#123; json_arr.push(json_arr.shift());//shift()删除数组的第一个元素并返回此元素，push()在数组尾部插入元素 togglePic();&#125;function togglePic()&#123; for(var i=0;i&lt;lis_len;i++)&#123;//遍历，给每张图片都赋值它当前对应的对象的值 moveAnimation(lis[i],&#123;width:json_arr[i].width, top:json_arr[i].top, left:json_arr[i].left, opacity:json_arr[i].opacity, zIndex:json_arr[i].z&#125;,function()&#123;click_btn=true;&#125;)//函数执行完毕后click_btn赋值为true，方可执行下次点击事件 &#125;&#125; 注：这里的JS代码也用到了moveAnimation函数，所以也要像轮播图（二）中的例子一样引入moveAnimation函数或引入其封装的moveAnimation.js 总结：旋转轮播图一般多用于图片尺寸相对较大的轮播图，且多用于电商网站中，这里我用的图片尺寸较小所以可能看上去效果不是特别好，如果感兴趣的话，小伙伴们可以亲手用大图试试哦！这种形式的轮播图只要搞懂了核心思想，其实也是很简单。本篇文章是由二蛋的前端博客：http://yyeggs.com/slideshow_rotation/ 整理，转载请注明","tags":[{"name":"JS","slug":"JS","permalink":"http://yyeggs.com/tags/JS/"},{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"}]},{"title":"轮播图（二）--4种无缝切换轮播图","date":"2019-03-23T07:22:20.000Z","path":"slideshow_switch/","text":"本篇介绍了目前最常用的4种无缝切换轮播图的实现方法，它们各有特点，但都引了同一个js动画函数（这个函数是我自己封装的），我们一起来看看吧 moveAnimation动画函数1234567891011121314151617181920212223242526272829303132333435363738394041424344function moveAnimation(obj, json, fn) &#123; clearInterval(obj.timer); obj.timer = setInterval(function () &#123; var flag = true; //用来判断是否停止定时器的条件，一定要写到定时器的里面（每隔30ms判断一次定时器是否应该停止），遍历的外面 for (var attr in json) &#123; var current = 0; if (attr == \"opacity\") &#123; current = parseInt(getStyle(obj, attr) * 100)||0; // 防止ie中不认识opacity从而输出undefined &#125; else &#123; current = parseInt(getStyle(obj, attr)); &#125; var step = (json[attr] - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); if (attr == \"opacity\") &#123; // 判断要做动画的样式中是否有opacity if (\"opacity\" in obj.style) &#123; // 判断浏览器是否支持opacity样式 obj.style.opacity = (current + step) / 100; &#125; else &#123; obj.style.filter = \"alpha(opacity=\" + (current + step) + \")\"; &#125; &#125; else if (attr == \"zIndex\") &#123; obj.style.zIndex=json[attr]; // zIndex一般不要加过渡动画 &#125; else &#123; obj.style[attr] = current + step + \"px\"; &#125; if (current != json[attr]) &#123; flag = false; &#125; &#125; if (flag) &#123; clearInterval(obj.timer); if (fn) &#123; fn();//定时器停止后执行回调函数 &#125; &#125; &#125;, 30)&#125;function getStyle(obj, attr) &#123; if (obj.currentStyle) &#123; return obj.currentStyle[attr]; &#125; else &#123; return window.getComputedStyle(obj, null)[attr]; &#125;&#125; 这个动画函数，几乎涵盖了大部分可以做动画的样式，当我们需要对元素进行动画时，可以直接使用它。在下面以及接下来有关于轮播图的博客中，我们都会使用这个函数，这里先介绍了，后续我们就直接使用了，不再做过多的介绍了哦。 无缝切换轮播图（有箭头，无序号）轮播图自动切换，鼠标进入停止切换，鼠标移除继续自动切换，并且可以通过点击左右箭头来控制切换上一张或下一张图片，没有图片序号，不能通过序号来进行图片切换 核心思想当前图片右侧的图片从右侧滑入，当前图片左侧的图片从左侧滑入，修改ul的left值，控制图片的滑动，当最后一张图片在可视区域时，下一张图片（也就是第一张图片）应该从右侧滑入才满足轮播图的需要，而不是从左侧滑动直到第一张。那么我们怎么解决最后一张图片在显示的同时，第一张图片又在可视区的右侧呢？其实上一篇博客中我们已经介绍了这种问题的解决方法：就是复制第一张图片，添加到最后一张图片的后面。兼顾对于左右箭头（也就是切换上一张、下一张图片的显示）和自动轮播效果，其实自动轮播效果就等同于每隔一段时间点击一次右箭头（切换下一张图片）。这样想，整个思路是不是清晰很多了，也就是我们只需要考虑点击不同的按钮ul向左或向右滑一定的距离即可 完整代码CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263html,body &#123; margin: 0; padding: 0;&#125;ul,ol &#123; list-style: none; margin: 0; padding: 0;&#125;.wrap &#123; width: 400px; height: 260px; padding: 5px; border: 1px solid #ccc; margin: 100px auto; position: relative;&#125;.slide &#123; width: 400px; height: 260px; position: relative; overflow: hidden;&#125;ul &#123; width: 3200px; position: absolute; left: 0;&#125;ul li &#123; float: left;&#125;img &#123; width: 400px; height: 260px; vertical-align: middle;&#125;.arr &#123; width: 400px; height: 50px; position: absolute; top: 50%; margin-top: -25px; display: none;&#125;.arr span &#123; width: 50px; line-height: 50px; text-align: center; font-family: \"黑体\"; font-size: 30px; background-color: rgba(0, 0, 0, 0.5); color: #ccc; position: absolute; cursor: pointer;&#125;.arr .pre &#123; left: 0px;&#125;.arr .next &#123; right: 0px;&#125; HTML1234567891011121314151617&lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;div class=\"slide\" id=\"slide\"&gt; &lt;ul id=\"ul\"&gt; &lt;li&gt;&lt;img src=\"img/1.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/3.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/4.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/5.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/6.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/7.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"arr\" id=\"arr\"&gt; &lt;span class=\"pre\" id=\"pre\"&gt;&lt;&lt;/span&gt; &lt;span class=\"next\" id=\"next\"&gt;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; JS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var wrap = document.getElementById('wrap');var ul = document.getElementById('ul');var lis = ul.children;var lis_len = lis.length; // 7var lefter = lis[0].offsetWidth;var arr = document.getElementById('arr');var next = document.getElementById('next');var pre = document.getElementById('pre');var key = 0;var timer = null;ul.append(lis[0].cloneNode(true)); //复制第1张图片并追加到最后,此时lis.length为8,而lis_len仍为7//自动执行动画nextAnimatetimer = setInterval(nextAnimate, 2000);//每隔3s执行一次点击next动画//分别点击next/pre执行函数arr.addEventListener('click', function (e) &#123; var e = e || window.e; var target = e.target || e.srcElement; var targetId = target.id; if (targetId === 'next') &#123; nextAnimate(); &#125; else &#123; preAnimate(); &#125;&#125;);//鼠标经过停止动画wrap.addEventListener('mouseover', function () &#123; arr.style.display = \"block\"; clearInterval(timer);&#125;)//鼠标移出开启动画wrap.addEventListener('mouseout', function () &#123; arr.style.display = \"none\"; timer = setInterval(nextAnimate, 2000);&#125;)//点击next按钮动画function nextAnimate() &#123; key++; if (key &gt; lis_len) &#123;//lis.length为8,当key为7时，要显示第8张（也就是第1张图），当key为8时要显示第2张图，第2张图的当前key值为1 ul.style.left = 0;//让当前显示的是第1张图 key = 1;//要显示第2张图 &#125; moveAnimation(ul, &#123; left: -key * lefter &#125;);//执行动画，滑动到要显示的图片&#125;//点击pre按钮动画function preAnimate() &#123; key--; if (key &lt; 0) &#123;//key为0时，要显示第1张图（也就是倒数第1张图），当key为-1时要显示倒数第2张图，也就是第7张图，第7张图的当前key值为6 ul.style.left = -lis_len * lefter + \"px\";//让当前显示的是倒数第1张图 key = lis_len-1;//要显示倒数第2张，也就是第7张图 &#125; moveAnimation(ul, &#123; left: -key * lefter &#125;);//执行动画，滑动到要显示的图片&#125; 注：上面的JS代码中，用key值保存当前显示的图片的下标，其最大值为“原始图片数组.length+1”（这里为8），当key=0时显示的是第1张图片，当key=6时当前显示的是第7张图片，当key=7时当前显示的是第8张（由第一张复制而来，视觉上等同于第1张图片），当key=8时要显示第2张图片，此时让ul.style.left=0瞬时让整个ul回归原位（此时可视区显示的是第一张图片，key=0,要显示第二张，则让key=1，再执行moveAnimation函数即可）。只要搞懂这个，上面的代码就没有什么难理解的了。另外，别忘了引上面那个moveAnimation动画函数 无缝切换轮播图（无箭头，有序号）轮播图自动切换，鼠标进入停止切换，鼠标移除继续自动切换，并且可以通过鼠标经过序号来控制切换任何一张图片，没有左右箭头，不能通过箭头来进行上一张或下一张图片切换 核心思想原理跟前面的相同，同样是复制第一张图片到最后。这种方式与之前不同的是，要根据图片的数目生成下标序号，通过鼠标经过下标序号来切换图片显示，当当前显示的图片跟我们要切换显示的图片不相邻时，可视区快速通过间隔图片直到滑动到我们所要显示的图片为止 完整代码CSS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364html,body &#123; margin: 0; padding: 0;&#125;ul,ol &#123; list-style: none; margin: 0; padding: 0;&#125;.wrap &#123; width: 400px; height: 260px; padding: 5px; border: 1px solid #ccc; margin: 100px auto; position: relative;&#125;.slide &#123; width: 400px; height: 260px; position: relative; overflow: hidden;&#125;ul &#123; width: 3200px; position: absolute; left: 0;&#125;ul li &#123; float: left;&#125;img &#123; width: 400px; height: 260px; vertical-align: middle;&#125;ol &#123; width: 200px; position: absolute; bottom: 5px; left: 50%; margin-left: -100px;&#125;ol li &#123; width: 20px; height: 20px; line-height: 20px; text-align: center; float: left; margin-right: 10px; background-color: #fff; color: #000; border-radius: 50%; cursor: pointer;&#125;ol li:last-child &#123; margin-right: 0;&#125;ol li.cur &#123; background-color: yellowgreen;&#125; HTML12345678910111213&lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;div class=\"slide\" id=\"slide\"&gt; &lt;ul id=\"ul\"&gt; &lt;li&gt;&lt;img src=\"img/1.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/3.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/4.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/5.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/6.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/7.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; JS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var wrap = document.getElementById('wrap');var slide = document.getElementById('slide');var ul = document.getElementById('ul');var lis = ul.children;var lis_len = lis.length;//7var lefter = lis[0].offsetWidth;var ol = document.createElement('ol');//创建olfor (var i = 0; i &lt; lis_len; i++) &#123; var li = document.createElement('li'); li.innerHTML = i + 1; ol.append(li);//把li追加到ol中&#125;slide.append(ol);//把ol追加到页面中var ollis = ol.children;ollis[0].className = \"cur\";ul.append(lis[0].cloneNode(true)); // 复制第一张图片插入到最后,此时lis.length为8,而lis_len仍为7var cir_num = 0;//控制当前circle序号var key = 0;//控制显示的图片序号//自动执行动画var timer = null;timer = setInterval(nextAnimate, 2000);//注：不要用ul.timer会跟moveAnimation里的定时器冲突//鼠标经过ollis切换到当前序号的图片显示for (var i = 0; i &lt; lis_len; i++) &#123; ollis[i].index = i;//获取当前遍历到的序号 ollis[i].addEventListener('mouseover', function () &#123;//鼠标移动到circle上切换图片 cir_num = key = this.index;//从当前图片开始播放切换 moveAnimation(ul, &#123; left: -key * lefter &#125;);//鼠标经过，滚动到当前图片 toggleCur(); &#125;)&#125;//鼠标经过停止动画wrap.addEventListener('mouseover', function () &#123; clearInterval(timer);&#125;);//鼠标移出开启动画wrap.addEventListener('mouseout', function () &#123; timer = setInterval(nextAnimate, 2000);&#125;)//自动执行动画函数function nextAnimate() &#123; key++; if (key &gt; lis_len) &#123;//lis.length值为8，当key值为8时，当前显示的是第1张图，要显示第2张图 ul.style.left = 0; key = 1;//如果key值为0会导致1张图重复播放 &#125; moveAnimation(ul, &#123; left: -key * lefter &#125;); cir_num++; cir_num&gt;lis_len-1?cir_num=0:cir_num;//当播放到第8张图片（也就是第1张图片）时，第1个数字为当前标识 toggleCur();&#125;//切换olli的类curfunction toggleCur() &#123; for (var i = 0; i &lt; lis_len; i++) &#123; ollis[i].className = \"\"; &#125; ollis[cir_num].className = \"cur\";&#125; 注：这里key存储的是可视区显示的图片的序号，由于复制了第一张图片的原因，key值最大可取到“原始图片数组.length+1”（这里为8），当key=8时为要显示第二张图片；而cir_num存储的是ol中下标的序号，其值最大为“原始图片数组.length-1”（这里为6），当cir_num=6时，当前显示的是第7张图片 无缝切换轮播图（有箭头，有序号）这种方式既可以自动轮播，又可以通过点击左右箭头切换图片，同时还可以通过下标来控制任何一张的显示。其实搞懂了上面两种方式，这种方式就显得很简单了，它就是上面两种方式的综合版 核心思想①复制第1张图片到最后②图片自动轮播即每隔一段时间点击一次右箭头（下一张）③通过key控制当前显示的图片，通过cir_num控制下标序号 完整代码CSS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788html,body &#123; margin: 0; padding: 0;&#125;ul,ol &#123; list-style: none; margin: 0; padding: 0;&#125;.wrap &#123; width: 400px; height: 260px; padding: 5px; border: 1px solid #ccc; margin: 100px auto; position: relative;&#125;.slide &#123; width: 400px; height: 260px; position: relative; overflow: hidden;&#125;ul &#123; width: 3200px; position: absolute; left: 0;&#125;ul li &#123; float: left;&#125;img &#123; width: 400px; height: 260px; vertical-align: middle;&#125;.arr &#123; width: 400px; height: 50px; position: absolute; top: 50%; margin-top: -25px; display: none;&#125;.arr span &#123; width: 50px; line-height: 50px; text-align: center; font-family: \"黑体\"; font-size: 30px; background-color: rgba(0, 0, 0, 0.5); color: #ccc; position: absolute; cursor: pointer;&#125;.arr .pre &#123; left: 0px;&#125;.arr .next &#123; right: 0px;&#125;ol &#123; width: 200px; position: absolute; bottom: 5px; left: 50%; margin-left: -100px;&#125;ol li &#123; width: 20px; height: 20px; line-height: 20px; text-align: center; float: left; margin-right: 10px; background-color: #fff; color: #000; border-radius: 50%; cursor: pointer;&#125;ol li:last-child &#123; margin-right: 0;&#125;ol li.cur &#123; background-color: yellowgreen;&#125; HTML1234567891011121314151617&lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;div class=\"slide\" id=\"slide\"&gt; &lt;ul id=\"ul\"&gt; &lt;li&gt;&lt;img src=\"img/1.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/3.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/4.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/5.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/6.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/7.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"arr\" id=\"arr\"&gt; &lt;span class=\"pre\" id=\"pre\"&gt;&lt;&lt;/span&gt; &lt;span class=\"next\" id=\"next\"&gt;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; JS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384var wrap = document.getElementById('wrap');var slide = document.getElementById('slide');var ul = document.getElementById('ul');var lis = ul.children;var lis_len = lis.length;//7var lefter = lis[0].offsetWidth;var arr = document.getElementById('arr');var ol = document.createElement('ol');//创建olfor (var i = 0; i &lt; lis_len; i++) &#123; var li = document.createElement('li'); li.innerHTML = i + 1; ol.append(li);//把li追加到ol中&#125;slide.append(ol);//把ol追加到页面中var ollis = ol.children;ollis[0].className = \"cur\";ul.append(lis[0].cloneNode(true)); // 复制第一张图片插入到最后,此时lis.length为8,而lis_len仍为7var cir_num = 0;//控制当前circle序号var key = 0;//控制显示的图片序号//自动执行动画nextAnimatevar timer = null;timer = setInterval(nextAnimate, 2000);//注：不能用ul.timer会跟moveAnimation里的定时器冲突//分别点击next/pre执行函数arr.addEventListener('click',function(e)&#123; var e=e||window.e; var target=e.target||e.srcElement; var targetId=target.id; if(targetId==='next')&#123; nextAnimate(); &#125;else&#123; preAnimate(); &#125;&#125;);//鼠标经过ollis切换到当前序号的图片显示for (var i = 0; i &lt; lis_len; i++) &#123; ollis[i].index = i;//获取当前遍历到的序号 //鼠标移动到circle上切换图片 ollis[i].addEventListener('mouseover', function () &#123; cir_num = key = this.index;//从当前图片开始播放切换 moveAnimation(ul, &#123; left: -key * lefter &#125;);//鼠标经过，滚动到当前图片 toggleCur(); &#125;)&#125;//鼠标经过停止动画wrap.addEventListener('mouseover', function () &#123; arr.style.display = 'block'; clearInterval(timer);&#125;);//鼠标移出开启动画wrap.addEventListener('mouseout', function () &#123; arr.style.display = 'none'; timer = setInterval(nextAnimate, 2000);&#125;)//next动画函数/自动执行动画函数，自动执行即每隔规定时间触发一次next动画函数function nextAnimate() &#123; key++; if (key &gt; lis_len) &#123;//lis.length值为8，当key值为8时，当前显示的是第1张图，要显示第2张图 ul.style.left = 0; key = 1;//如果key值为0会导致1张图重复播放 &#125; moveAnimation(ul, &#123; left: -key * lefter &#125;); cir_num++; cir_num&gt;lis_len-1?cir_num=0:cir_num;//当播放到第8张图片（也就是第1张图片）时，第1个数字为当前标识 toggleCur();&#125;//pre动画function preAnimate() &#123; key--; if (key &lt; 0) &#123; ul.style.left = -lis_len * lefter + \"px\"; key = lis_len-1; &#125; moveAnimation(ul, &#123; left: -key * lefter &#125;); cir_num--; cir_num&lt;0?cir_num=lis_len-1:cir_num; toggleCur();&#125;//切换olli的类curfunction toggleCur() &#123; for (var i = 0; i &lt; lis_len; i++) &#123; ollis[i].className = \"\"; &#125; ollis[cir_num].className = \"cur\";&#125; 上面这三种就是无缝切换轮播图的三种形式了，下面我们将介绍一种另类的无缝切换轮播图–经典网易轮播图 经典网易轮播图我之所以称其为经典网易轮播图，是因为这个轮播图是我在浏览网易页面时发现的，而且这种轮播图在其它页面比较少见，可能是因为其外观与“无缝切换轮播图（有箭头，有序号）”一样，但实现方法稍微复杂，所以采用率比较小。但是这种轮播图的交互效果跟上面或者说我们平时用的带序号的轮播图的交互效果是不同的，甚至可以说这种交互更优于其它交互（仅代表我个人见解） 核心思想网易轮播图不同于上一种轮播图的地方在于当通过下标切换图片时，若要切换的两张图片之间不相邻，那么上一种轮播图会快速经过中间的间隔图片，而网易轮播图则直接切换到目标图片，并不会经过中间间隔的图片。由于这种交互方式的问题，我们就不能再用上面那种布局思路（即把所有图片在ul中横向排列，通过控制ul的left值来控制图片的滑动），而是要把图片堆叠到一起，当鼠标经过某个序号时，对应序号的图片滑进可视区，那这样的话，我们也就不用再复制第一张图片到ul末尾了 完整代码CSS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788html,body &#123; margin: 0; padding: 0;&#125;ul,ol &#123; list-style: none; margin: 0; padding: 0;&#125;.wrap &#123; width: 400px; height: 260px; padding: 5px; border: 1px solid #ccc; margin: 100px auto; position: relative;&#125;.slide &#123; width: 400px; height: 260px; position: relative; overflow: hidden;&#125;ul &#123; width: 400px;&#125;ul li &#123; position: absolute; top: 0; left: 0;&#125;img &#123; width: 400px; height: 260px; vertical-align: middle;&#125;.arr &#123; width: 400px; height: 50px; position: absolute; top: 50%; margin-top: -25px; display: none;&#125;.arr span &#123; width: 50px; line-height: 50px; text-align: center; font-family: \"黑体\"; font-size: 30px; background-color: rgba(0, 0, 0, 0.5); color: #ccc; position: absolute; cursor: pointer;&#125;.arr .pre &#123; left: 0px;&#125;.arr .next &#123; right: 0px;&#125;ol &#123; width: 200px; position: absolute; bottom: 5px; left: 50%; margin-left: -100px;&#125;ol li &#123; width: 20px; height: 20px; line-height: 20px; text-align: center; float: left; margin-right: 10px; background-color: #fff; color: #000; border-radius: 50%; cursor: pointer;&#125;ol li:last-child &#123; margin-right: 0;&#125;ol li.cur &#123; background-color: yellowgreen;&#125; HTML1234567891011121314151617&lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;div class=\"slide\" id=\"slide\"&gt; &lt;ul id=\"ul\"&gt; &lt;li&gt;&lt;img src=\"img/1.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/3.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/4.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/5.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/6.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/7.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"arr\" id=\"arr\"&gt; &lt;span class=\"pre\" id=\"pre\"&gt;&lt;&lt;/span&gt; &lt;span class=\"next\" id=\"next\"&gt;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; JS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var wrap = document.getElementById('wrap');var slide = document.getElementById('slide');var ul = document.getElementById('ul');var lis = ul.children;var lis_len=lis.length;//7var lefter=lis[0].offsetWidth;var arr = document.getElementById('arr');var ol = document.createElement('ol');//创建olfor (var i = 0; i &lt; lis_len; i++) &#123; var li = document.createElement('li'); li.innerHTML = i + 1; ol.append(li);//把li追加到ol中&#125;slide.append(ol);//把ol追加到页面中var ollis = ol.children;ollis[0].className = \"cur\";//当前显示第1张图片，其它图片都叠放在右侧for (var i = 0; i &lt; lis_len; i++) &#123; lis[i].style.left = lefter + \"px\";&#125;lis[0].style.left = 0;var key = 0;//自动播放执行var timer = null;timer = setInterval(nextAnimate, 2000);//分别点击next/pre执行函数arr.addEventListener('click',function(e)&#123; var e=e||window.e; var target=e.target||e.srcElement; var targetId=target.id; if(targetId==='next')&#123; nextAnimate(); &#125;else&#123; preAnimate(); &#125;&#125;);//鼠标经过ollis切换到当前序号的图片显示for (var i = 0; i &lt; lis_len; i++) &#123; ollis[i].index = i; ollis[i].addEventListener('mouseover', function () &#123; that = this.index; if (that &gt; key) &#123; moveAnimation(lis[key], &#123; left: -lefter &#125;); lis[that].style.left = lefter + \"px\"; &#125; else &#123; moveAnimation(lis[key], &#123; left: lefter &#125;); lis[that].style.left = -lefter + \"px\"; &#125; key = that; moveAnimation(lis[key], &#123; left: 0 &#125;); toggleCur(); &#125;)&#125;//鼠标经过停止计时器，arr显示wrap.addEventListener('mouseover', function () &#123; clearInterval(timer); arr.style.display = \"block\";&#125;)//鼠标移出开启定时器，arr隐藏wrap.addEventListener('mouseout', function () &#123; timer = setInterval(nextAnimate, 2000); arr.style.display = \"none\";&#125;)//点击下一张next函数/自动播放函数function nextAnimate() &#123; moveAnimation(lis[key], &#123; left: -lefter &#125;);//先将当前图片向左滑动 key++;//key值切换为要显示的图片的序号 key &gt; lis_len - 1 ? key = 0 : key;//首尾判断 lis[key].style.left = lefter + \"px\";//要显示的图片迅速切换到指定位置 moveAnimation(lis[key], &#123; left: 0 &#125;);//要显示的图片从指定位置滑到显示位 toggleCur();//切换ollis的cur&#125;//切换上一张pre函数function preAnimate() &#123; moveAnimation(lis[key], &#123; left: lefter &#125;); key--; key &lt; 0 ? key = lis_len-1 : key; lis[key].style.left = -lefter + \"px\"; moveAnimation(lis[key], &#123; left: 0 &#125;); toggleCur();&#125;//切换olli的类curfunction toggleCur() &#123; for (var i = 0; i &lt; lis_len; i++) &#123; ollis[i].className = \"\"; &#125; ollis[key].className = \"cur\";&#125; 注：key值为当前显示的或要显示的图片的序号，当要显示的图片的序号大于当前显示的图片的序号时，从右向左滑动，否则从左向右滑动 总结：这种4中形式的是目前最常用的轮播图，如果小伙伴们还有其它轮播图的实现方法，或者对我整理的这些有疑问或指正请在下面告诉我哦本篇文章是由二蛋的前端博客：http://yyeggs.com/slideshow_switch/ 整理，转载请注明","tags":[{"name":"JS","slug":"JS","permalink":"http://yyeggs.com/tags/JS/"},{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"}]},{"title":"轮播图（一）--平滑无缝滚动轮播图","date":"2019-03-23T07:22:20.000Z","path":"slideshow_marquee/","text":"很早之前就想整理一篇关于轮播图的博客了，可一直也没有时间，放着放着就忘了，昨天看到一个比较有意思的轮播图，一下子又勾起了我的兴趣，今天就开始着手整理轮播图的几种实现方法，几乎可以涵盖目前网页中大部分轮播图形式，今天先整理一篇稍微简单点的–平滑无缝滚动轮播图 核心思想及问题平滑无缝滚动轮播图的核心思想很简单，就是外盒子给定宽度（大约是一到两张图片的宽度）而内盒子（这里用ul标签）宽度则是所有图片宽度的总和,并且ul相对于外盒子绝对定位，所有图片左浮动，排成一行，改变ul的left值使其向左滑动即可。但这里有个很关键的问题就是，当最后一张图片完全进入可视区域后，整个轮播图就像下面这样而此时要继续滚动，则会造成下面这样的效果可视区域的右侧出现了空白，而我们是想让这空白部分显示第一张图，也就是说我们想让可是区域同时显示最后一张图和第一张图的一部分，但是所有的图片都在ul中，而ul中的图片是横向排列的，那我们该怎么办呢？很简单，我们复制第一张图片到最后就可以解决。同样道理，当复制的第一张图片完全进入可视区域后，此时最后一张图片还没有完全滑出可视区域范围，无法让ul的left=0，所以我们还得复制第二张图片放到最后（也就是复制的第一张图片的后面）当第三张图片滑出可视区域范围时，设置ul的left为0,则轮播图的循环从头开始。 完整代码CSS1234567891011121314151617181920212223242526272829303132333435363738html,body &#123; margin: 0; padding: 0;&#125;ul,ol &#123; list-style: none; margin: 0; padding: 0;&#125;.wrap &#123; width: 600px; height: 260px; padding: 5px; border: 1px solid #ccc; margin: 100px auto; position: relative;&#125;.slide &#123; width: 600px; height: 260px; position: relative; overflow: hidden;&#125;ul &#123; width: 3600px; position: absolute; left: 0;&#125;ul li &#123; float: left;&#125;img &#123; width: 400px; height: 260px; vertical-align: middle;&#125; HTML12345678910111213&lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;div class=\"slide\" id=\"slide\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"img/1.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/3.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/4.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/5.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/6.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/7.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; JS12345678910111213141516171819var wrap = document.getElementById('wrap');var ul = wrap.getElementsByTagName('ul')[0];var lis = ul.children;var w_lefter=lis[0].offsetWidth;var lis_len = lis.length;//7var lefter = 0; //ul的left值ul.append(lis[0].cloneNode(true), lis[1].cloneNode(true)); //复制第1/2张图片并追加到最后,此时lis.length为9,而lis_len仍为7ul.timer = setInterval(nextAnimate, 6);function nextAnimate() &#123; //动画函数 lefter--; lefter &lt; -lis_len*w_lefter ?lefter = 0 : lefter; ul.style.left = lefter + \"px\";&#125;wrap.addEventListener('mouseover', function () &#123; clearInterval(ul.timer);&#125;)wrap.addEventListener('mouseout', function () &#123; ul.timer = setInterval(nextAnimate, 6);&#125;) 总结：这种形式的轮播图只要搞懂了核心思想，其实很简单，也是比较常用的，而后面我也将介绍其他几种稍微复杂点的轮播图，感兴趣的话可以关注一下。本篇文章是由二蛋的前端博客：http://yyeggs.com/slideshow_marquee/ 整理，转载请注明","tags":[{"name":"JS","slug":"JS","permalink":"http://yyeggs.com/tags/JS/"},{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"}]},{"title":"CSS之斜切角","date":"2018-11-06T07:59:23.000Z","path":"CSS_angle/","text":"斜切角在Web设计和印刷中是相当受欢迎的样式。它通常是在一个或多个元素的角落切一个45°的角（也就是所谓的斜切角）","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yyeggs.com/tags/CSS/"},{"name":"background","slug":"background","permalink":"http://yyeggs.com/tags/background/"}]},{"title":"CSS画对话框","date":"2018-11-02T03:10:41.000Z","path":"CSS_dialogue_box/","text":"在实际工作中，有时候为了项目中页面的美观性，会需要把文字放到类似对话框的元素中，上一篇博客介绍了用CSS画各种图形，那这一篇我们就来了解一下怎样用CSS来画对话框或对话气泡吧 小尾巴在正文开始之前，我们首先来看一下在下面用到的对话框的小尾巴是怎么画出来的12345678.tail-ltop &#123; width: 100px; height: 100px; border-top: 30px solid #abe1eb; -moz-border-radius: 100px 0 0 0; -webkit-border-radius: 100px 0 0 0; border-radius: 100px 0 0 0;&#125; 其实这个小尾巴是由下面这个图形，经过调整圆角度和边框宽度得到的从上面的代码里改变边框宽度及圆角弧度即可得到多个方向的小尾巴，而且还可以给它应用transform：rotate()还可以得到各个方向的小尾巴图形，再结合矩形，就可以组成对话框啦12345678.tail-rtop &#123; width: 100px; height: 100px; border-top: 30px solid #abe1eb; -moz-border-radius: 0 100px 0 0; -webkit-border-radius: 0 100px 0 0; border-radius: 0 100px 0 0;&#125; 12345678.tail-rtop &#123; width: 100px; height: 100px; border-right: 30px solid #abe1eb; -moz-border-radius: 0 100px 0 0; -webkit-border-radius: 0 100px 0 0; border-radius: 0 100px 0 0;&#125; 12345678.tail-rbottom &#123; width: 100px; height: 100px; border-right: 30px solid #abe1eb; -moz-border-radius: 0 0 100px 0; -webkit-border-radius: 0 0 100px 0; border-radius: 0 0 100px 0;&#125; 12345678.tail-rbottom &#123; width: 100px; height: 100px; border-bottom: 30px solid #abe1eb; -moz-border-radius: 0 0 100px 0; -webkit-border-radius: 0 0 100px 0; border-radius: 0 0 100px 0;&#125; 12345678.tail-lbottom &#123; width: 100px; height: 100px; border-bottom: 30px solid #abe1eb; -moz-border-radius: 0 0 0 100px; -webkit-border-radius: 0 0 0 100px; border-radius: 0 0 0 100px;&#125; 12345678.tail-lbottom &#123; width: 100px; height: 100px; border-left: 30px solid #abe1eb; -moz-border-radius: 0 0 0 100px; -webkit-border-radius: 0 0 0 100px; border-radius: 0 0 0 100px;&#125; 12345678.tail-ltop &#123; width: 100px; height: 100px; border-left: 30px solid #abe1eb; -moz-border-radius: 100px 0 0 0; -webkit-border-radius: 100px 0 0 0; border-radius: 100px 0 0 0;&#125; 小尾巴对话框圆角矩形12345678910111213141516171819202122.roundrect-tail &#123; width: 180px; background: #abe1eb; -moz-border-radius: 20px; -webkit-border-radius: 20px; border-radius: 20px; position: relative; padding: 15px;&#125;.roundrect-tail::after &#123; content: ''; width: 100px; height: 100px; position: absolute; bottom: -35px; left: -50px; border-right: 60px solid #abe1eb; -moz-border-radius: 0 0 100px 0; -webkit-border-radius: 0 0 100px 0; border-radius: 0 0 100px 0; z-index: -1;&#125; 根据实际情况，自行调整小尾巴的朝向，上面也已经列出各个方向的小尾巴，如果还不能满足可借用transform：rotate()进行调整，这里就不再多说了注：这里定位用的是bottom而不是top为什么？top是根据相对定位的顶点进行定位，而bottom是根据相对定位的底端进行定位，这里因为对话框没有给高度，就是根据内容自适应，所以顶点不会改变，但是当内容过多撑起对话框时，底端就会改变，而我们要求小尾巴是根据元素的高度改变而调整上下位置的，所以这里用bottom而不用top。下面的例子中也一样 椭圆1234567891011121314151617181920212223.oval-tail &#123; width: 180px; background: #abe1eb; -moz-border-radius: 50%; -webkit-border-radius: 50%; border-radius: 50%; position: relative; padding: 25px 30px; text-align: center;&#125;.oval-tail::before &#123; content: ''; width: 100px; height: 100px; position: absolute; bottom: -30px; left: -50px; border-right: 60px solid #abe1eb; -moz-border-radius: 0 0 100px 0; -webkit-border-radius: 0 0 100px 0; border-radius: 0 0 100px 0; z-index: -1;&#125; 其实就是上面那个例子，把矩形变成椭圆即可，是不是很简单，当然，你也可以调整小尾巴的弧度、位置和椭圆的弧度，形成各种图形，在此就不多做描述了 三角形+对话框字符法1234567891011121314151617181920212223&lt;style&gt;.roundrect-bot &#123; width: 180px; background: #abe1eb; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; position: relative; padding: 10px; text-align: center;&#125;.bot&#123; position: absolute; bottom: -45px; left: 15px; font-size: 70px; color: #abe1eb;&#125;&lt;/style&gt;&lt;div class=\"roundrect-bot\"&gt;请叫我小仙女请叫我小仙女 &lt;span class=\"bot\"&gt;◆&lt;/span&gt;&lt;/div&gt; 这是用两个元素来实现的，从上面代码中，我们可以发现，其实用一个元素也可以实现，.bot元素完全可以用.roundrect-bot::after来替代，效果跟上面是一样的123456789101112131415161718.roundrect-bot &#123; width: 180px; background: #abe1eb; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; position: relative; padding: 10px; text-align: center;&#125;.roundrect-bot::after&#123; content: '◆'; position: absolute; bottom: -45px; left: 15px; font-size: 70px; color: #abe1eb;&#125; 等腰直角三角形1234567891011121314151617181920.roundrect-triangle1&#123; width: 180px; background: #abe1eb; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; position: relative; padding: 10px; text-align: center;&#125;.roundrect-triangle1::before &#123; content:''; width: 0; height: 0; position: absolute; bottom: -30px; left: 20px; border: 15px solid #abe1eb; border-color: #abe1eb transparent transparent;&#125; 当然有了这个例子和上一篇博客，要改变这个三角形的朝向是轻而易举的 直角三角形123456789101112131415161718192021.roundrect-triangle2&#123; width: 180px; background: #abe1eb; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; position: relative; padding: 10px; text-align: center;&#125;.roundrect-triangle2::before &#123; content:''; width: 0; height: 0; position: absolute; bottom: -24px; left: 20px; border-width: 12px 12px; border-style: solid; border-color: #abe1eb #abe1eb transparent transparent;&#125; 根据上面两个例子，我们发现可以通过调整border的border-width和border-color来改变三角形的形状和方向，从而改变整个对话框的样式 钝角三角形123456789101112131415161718192021222324252627282930313233.roundrect-triangle3&#123; width: 180px; height: 32px; background: #abe1eb; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; position: relative; padding: 10px; text-align: center;&#125;.roundrect-triangle3::before &#123; content:''; width: 0; height: 0; position: absolute; top: 19px; left: -40px; border-width:20px; border-style:solid; border-color: transparent #abe1eb #abe1eb transparent;&#125;.roundrect-triangle3::after&#123; content:''; width: 0; height: 0; position: absolute; top: 36px; left: -40px; border-width:10px 20px 12px 20px; border-style:dashed solid solid dashed; border-color:transparent #fff #fff transparent;&#125; 这是我看到的很多博客做这种效果都是画一大一小两个直角三角形，并且用小直角三角形遮住大的直角三角形（见下图），当让红色部分变成背景色时，就实现上面的效果了但这样做有一个弊端，就是当背景不是纯色（比如：渐变色或使用图片为背景）时，就无法实现此效果了，而且实际应用中，像这种对话框往往就是用在非纯色背景的情况下的，所以我想到了是否可以延续上面的用两个三角组成这个图形，但是不是用遮盖，而是用旋转方法，也就是用一个有边框生成的直角三角形和一个底边框生成的钝角三角形旋转一定度数组成果然实现了，代码如下1234567891011121314151617181920212223242526272829303132333435363738.roundrect-triangle3&#123; width: 180px; height: 32px; background: #abe1eb; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; position: relative; padding: 10px; text-align: center;&#125;.roundrect-triangle3::before &#123; content:''; width: 0; height: 0; position: absolute; top: 19px; left: -19px; border-width:10px; border-style:solid; border-color:transparent #abe1eb #abe1eb transparent;&#125;.roundrect-triangle3::after&#123; content:''; width: 0; height: 0; position: absolute; top: 29px; left: -52px; border-width: 10px 20px 10px 40px; border-style: solid; border-color:transparent transparent #abe1eb transparent; -webkit-transform: rotate(-30deg); -moz-transform: rotate(-30deg); -o-transform: rotate(-30deg); -ms-transform: rotate(-30deg); transform: rotate(-30deg);&#125; 写上面那段代码的时候，我发现为什么我要用两个三角形拼合起来呢，直接用像上面那样用底边框实现一个钝角三角形，然后旋转一定度数不一样可以实现，而且相较于上面还更简单，唯一不同的是底边框变为上边框而已，这样旋转的角度会小一些，当然，你如果执意喜欢用底边框来变换，也是可以的 1234567891011121314151617181920212223.roundrect-triangle3&#123; width: 180px; height: 32px; background: #abe1eb; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; position: relative; padding: 10px; text-align: center;&#125;.roundrect-triangle3::before &#123; content:''; width: 0; height: 0; position: absolute; top: 34px; left: -34px; border-width: 15px 20px 10px 35px; border-style: solid; border-color: #abe1eb transparent transparent transparent; transform: rotate(-52deg);&#125; 无背景色对话框1234567891011121314151617181920212223242526272829303132.roundrect-triangle4 &#123; width: 180px; border: 2px solid #abe1eb; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; position: relative; padding: 10px; text-align: center;&#125;.roundrect-triangle4::before &#123; content: ''; width: 0; height: 0; position: absolute; left:80px; bottom:-32px; border-width:15px; border-style:solid; border-color:#abe1eb transparent transparent;&#125;.roundrect-triangle4::after&#123; content: ''; width: 0; height: 0; position: absolute; left:80px; bottom:-28px; border-width:15px; border-style:solid dashed dashed; border-color:#ffffff transparent transparent;&#125; 注：这里所说的无背景，其实是指背景和边框颜色不一样，本例中，背景为白色，.roundrect-triangle4::before为元素边框色的三角形.roundrect-triangle4::after为元素背景色的三角形，用第二个遮住第一个大部分，只留下下面那个三角轮廓，就实现了上图中的效果了 气泡对话框123456789101112131415161718192021222324252627282930313233.roundrect-bubble &#123; max-width: 200px; width: fit-content; background: #abe1eb; border: 2px solid #abe1eb; -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 50%; position: relative; padding: 25px; text-align: center; margin: 100px;&#125;.roundrect-bubble::before &#123; content: ''; width: 25px; height: 25px; background: #abe1eb; position: absolute; left: 0; bottom: -20px; border-radius: 50%;&#125;.roundrect-bubble::after &#123; content: ''; width: 15px; height: 15px; background: #abe1eb; position: absolute; left: -15px; bottom: -40px; border-radius: 50%;&#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yyeggs.com/tags/CSS/"}]},{"title":"纯CSS画各种图形","date":"2018-10-29T02:04:13.000Z","path":"CSS_border_graph/","text":"在实际应用中很多地方会用到一些小的形状图标及显示框等各种图形，而这时候如果使用图片不仅不能自适应内容还会在加载页面时增加图片请求从而降低页面性能，此时我们就可以用纯CSS的各种属性来解决这个问题了 CSS之border前言由于我们下面介绍的方法大多数都要用到border这个样式属性，所以先介绍一下它，如果想对border进一步了解，可以翻看我前面的那篇博客。最初border是用来给元素加边框的，随着CSS的发展和实际开发的需求，border被用在更多地方，比如用border的属性实现椭圆、梯形、心形等各种图形以及各种对话气泡上，在这里我们先看一下border的四个边属性12345678.border&#123; width: 0; height: 0; border-top: 50px solid red; border-right: 50px dashed blue; border-bottom: 50px solid yellow; border-left: 50px solid green;&#125; 注：如果要实现没有下边框，也就是没有上图中的黄色部分，则应该把上面代码中的border-bottom的颜色yellow改为transparent而不是把border-bottom去掉，两种做法的区别见下图，第一个是改为transparent，第二个是直接去掉border-bottom属性 矩形正方形12345.square&#123; width: 0; height: 0; border: 50px solid yellowgreen;&#125; 长方形12345678.square&#123; width: 0; height: 0; border-top: 50px solid yellowgreen; border-right: 100px solid yellowgreen; border-bottom: 50px solid yellowgreen; border-left: 100px solid yellowgreen;&#125; 平行四边形12345678910.parallelogram&#123; width: 100px; height: 50px; -webkit-transform: skew(20deg);/* Safari 和 Chrome */ -moz-transform: skew(20deg);/* Firefox */ -o-transform: skew(20deg);/* Opera */ -ms-transform: skew(20deg);/* IE 9 */ transform: skew(20deg); background: yellowgreen;&#125; 注：transform是CSS3的属性，skew()为倾斜角度，括号中分别为沿X轴和Y轴两个值，用逗号分隔，当只有一个值时默认为沿X轴倾斜，允许负值（反方向），这里我就不贴图了，感兴趣的话可以拿上面那段代码改改试试 菱形123456789101112131415.rhomb&#123; width: 100px; height: 100px; -webkit-transform-origin: 0 100%; -moz-transform-origin: 0 100%; -o-transform-origin: 0 100%; -ms-transform-origin: 0 100%; transform-origin: 0 100%; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -o-transform: rotate(45deg); -ms-transform: rotate(45deg); transform: rotate(45deg); background: yellowgreen;&#125; 注：transform-origin规定旋转基点，rotate()旋转角度 梯形梯形-向上1234567.trapezoid-top&#123; width: 100px; height: 0; border-bottom: 100px solid yellowgreen; border-right: 50px solid transparent; border-left: 50px solid transparent;&#125; 如果直接看上面的代码不太明白，可以看下面的图例这张图其实跟CSS之border前言中的图一样，只是这里的左右边框宽度跟上下边框宽度不一样，当然当这四种颜色相同时就是我们的2.1中长方形的样子了，对比这张图跟最终的效果图有什么不一样？对了，就是我们上面提到过的把borer-top属性去掉，那就成了下面这种样子然后我们再把左右边框变成透明的就OK了怎么样，是不是跟上面的效果图一样了。理解了这个，下面的梯形面向各个方向我们就不详细解释原理了 梯形-向下1234567.trapezoid-bottom&#123; width: 100px; height: 0; border-top: 100px solid yellowgreen; border-right: 50px solid transparent; border-left: 50px solid transparent;&#125; 没错，就是把上面的代码中的bottom改成top即可 梯形-向左1234567.trapezoid-left&#123; width: 100px; height: 100px; border-right: 100px solid yellowgreen; border-top: 50px solid transparent; border-bottom: 50px solid transparent;&#125; 注：这里的height指定了外边框的长度，所以必须有，否则梯形就变成了三角形 梯形-向右1234567.trapezoid-right&#123; width: 100px; height: 100px; border-left: 100px solid yellowgreen; border-top: 50px solid transparent; border-bottom: 50px solid transparent;&#125; 圆角梯形12345678910111213141516.trapezoid-radius&#123; width: 100px; height: 40px; background: yellowgreen; border-radius: .5em .5em 0 0; -webkit-transform: scaleY(1.3) perspective(.5em) rotateX(5deg); -moz-transform: scaleY(1.3) perspective(.5em) rotateX(5deg); -ms-transform: scaleY(1.3) perspective(.5em) rotateX(5deg); -o-transform: scaleY(1.3) perspective(.5em) rotateX(5deg); transform: scaleY(1.3) perspective(.5em) rotateX(5deg);/*scaleY: 纵轴放大1.3倍，使梯形高度等于height；perspective:3d透视效果，元素距离视图的距离*/ -webkit-transform-origin: bottom; -moz-transform-origin: bottom; -ms-transform-origin: bottom; -o-transform-origin: bottom; transform-origin: bottom;/*以底轴为基轴*/&#125; 圆角梯形的实现原理跟其它的是不同的，圆角梯形是先实现圆角矩形，然后给矩形做3D变换，让它以底边框为基轴，向Z轴方向倾斜，视觉上就形成了圆角梯形 三角形三角形-向上123456.triangle-top &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-color: transparent transparent yellowgreen;&#125; 这里border-color有三个值，第一个代表上边框颜色，第二个代表左右边框颜色，第三个代表下边框颜色，关于这些在我上一篇博客中有详细的描述，感兴趣的话可以看看。其实还有别的写法，比如下面这样123456.triangle-top &#123; width: 0; height: 0; border: 50px solid transparent; border-bottom: 50px solid yellowgreen;&#125; 这种写法可以实现等腰三角形而非等边三角形 三角形-向下123456.triangle-bottom &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-color: yellowgreen transparent transparent;&#125; 三角形-向左123456.triangle-left &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-color: transparent yellowgreen transparent transparent;&#125; 三角形-向右123456.triangle-right &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-color: transparent transparent transparent yellowgreen;&#125; 三角形-左上123456.triangle-ltop &#123; width: 0; height: 0; border-top: 100px solid yellowgreen; border-right: 100px solid transparent;&#125; 三角形-右上123456.triangle-rtop &#123; width: 0; height: 0; border-right: 100px solid yellowgreen; border-bottom: 100px solid transparent;&#125; 三角形-左下123456.triangle-lbottom &#123; width: 0; height: 0; border-left: 100px solid yellowgreen; border-top: 100px solid transparent;&#125; 三角形-右下123456.triangle-rbottom &#123; width: 0; height: 0; border-bottom: 100px solid yellowgreen; border-left: 100px solid transparent;&#125; 三角形-上下-对角12345678.triangle-tbottom-diagonal &#123; width: 0; height: 0; border-top: 50px solid yellowgreen; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 50px solid yellowgreen;&#125; 其实是向上的三角和向下的三角的总和，不信可以把border-top和border-bottom的颜色改成不一样的就会发现了 三角形-上下-覆盖1234567891011121314151617181920.triangle-tbottom-cover &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid yellowgreen; position: relative;&#125;.triangle-tbottom-cover:after &#123; content: \" \"; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid yellowgreen; position: absolute; top: 50px; left: -50px;&#125; 其实是原理跟上一个一样，上下三角形要覆盖所以用到了定位而且把上下三角形分给了当前元素和当前元素的伪元素:after调整.triangle-tbottom-cover:after的top值即可得到六角形 三角形-上下-时间沙漏123456789101112131415161718192021.triangle-tbottom-time &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 60px solid yellowgreen; position: relative; margin-top: 50px&#125;.triangle-tbottom-time:after &#123; content: \" \"; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 60px solid yellowgreen; position: absolute; top: -40px; left: -50px;&#125; 跟上一个类似，只是定位的距离做了一些改变 圆12345678.semicircle &#123; width: 100px; height: 100px; background: yellowgreen; -webkit-border-radius: 50%; -moz-border-radius: 50%; border-radius: 50%;&#125; 注：宽高要相等，否则就是椭圆了 同心圆123456789.circle-circle &#123; width: 100px; height: 100px; border: 20px solid #669; background: #fff; -moz-border-radius: 100px; -webkit-border-radius: 100px; border-radius: 100px;&#125; 椭圆-水平12345678.oval-horizontal &#123; width: 100px; height: 50px; background: yellowgreen; -webkit-border-radius: 50px/25px; -moz-border-radius: 50px/25px; border-radius: 50px/25px;&#125; 注：水平椭圆即宽度&gt;高度；在本例中border-radius的取值，第一个值为宽度的一半即半长轴，第二个值为高度的一半即半短轴，但也可以直接写成border-radius:50%即宽高都各取一半 椭圆-垂直12345678.oval-vertical &#123; width: 50px; height: 100px; background: yellowgreen; -webkit-border-radius: 25px/50px -moz-border-radius: 25px/50px; border-radius: 25px/50px;&#125; 注：水平椭圆即宽度&lt;高度；在本例中border-radius的取值，第一个值为宽度的一半即半短轴，第二个值为高度的一半即半长轴，但也可以直接写成border-radius:50%即宽高都各取一半 表图123456789.chartColorful &#123; width: 0; height: 0; border-top: 50px solid red; border-right: 50px solid blue; border-bottom: 50px solid yellow; border-left: 50px solid green;-moz-border-radius: 50px; -webkit-border-radius:50px; border-radius: 50%;&#125; 其实这种写法跟1中CSS之border前言一样，只是在那个基础上增加了圆角弧度border-radius而已 半圆-上半圆12345678.semicircle-top &#123; width: 100px;/*直径*/ height: 50px;/*半径*/ background: yellowgreen; -webkit-border-radius: 100px 100px 0 0; -moz-border-radius: 100px 100px 0 0; border-radius: 100px 100px 0 0;/*半圆弧度为直径*/&#125; border-radius中取值的顺序为左上角 右上角 右下角 左下角，具体请看我的博客CSS之border详解 半圆-下半圆12345678.semicircle-bottom &#123; width: 100px;/*直径*/ height: 50px;/*半径*/ background: yellowgreen; -webkit-border-radius: 0 0 100px 100px; -moz-border-radius: 0 0 100px 100px; border-radius: 0 0 100px 100px;/*半圆弧度为直径*/&#125; 半圆-左半圆12345678.semicircle-left &#123; width: 50px;/*半径*/ height: 100px;/*直径*/ background: yellowgreen; -webkit-border-radius: 100px 0 0 100px; -moz-border-radius: 100px 0 0 100px; border-radius: 100px 0 0 100px;/*半圆弧度为直径*/&#125; 半圆-右半圆12345678.semicircle-right &#123; width: 50px;/*半径*/ height: 100px;/*直径*/ background: yellowgreen; -webkit-border-radius: 0 100px 100px 0; -moz-border-radius: 0 100px 100px 0; border-radius: 0 100px 100px 0;/*半圆弧度为直径*/&#125; 四分之一圆-上、下、左、右123456789.quarterCircle &#123; width: 0; height: 0; border-top: 50px solid yellowgreen; border-right: 50px solid transparent; border-left: 50px solid transparent; -moz-border-radius: 50px; -webkit-border-radius:50px; border-radius: 50%;&#125; 跟前面三角形对应的实现方法一样，只是在三角形的基础上加上border-radius：50%即可，所以这里就不再重复写了，如果需要可以在评论去留言 四分之一圆-左上12345678.quarterCircle-ltop &#123; width: 50px; height: 50px; background: yellowgreen; -moz-border-radius: 100% 0 0 0; -webkit-border-radius: 100% 0 0 0; border-radius: 100% 0 0 0;&#125; 注：因为这里画的是四分之一圆，所以宽高即为半径，而border-radius的取值等于半径时即可成圆的弧度，所以这里border-radius取值为100%，当然也可以不用百分比表示，而用像素值50px，原理是一样的当border-radius取值为50%时是如下形状 四分之一圆-右上12345678.quarterCircle-rtop &#123; width: 50px; height: 50px; background: yellowgreen; -moz-border-radius: 100% 0 0 0; -webkit-border-radius: 100% 0 0 0; border-radius:0 100% 0 0;&#125; 四分之一圆-右下12345678.quarterCircle-rbottom &#123; width: 50px; height: 50px; background: yellowgreen; -moz-border-radius: 100% 0 0 0; -webkit-border-radius: 100% 0 0 0; border-radius:0 0 100% 0;&#125; 四分之一圆-左下12345678.quarterCircle-lbottom &#123; width: 50px; height: 50px; background: yellowgreen; -moz-border-radius: 100% 0 0 0; -webkit-border-radius: 100% 0 0 0; border-radius:0 0 0 100%;&#125; 四分之三圆-上开口123456789.chart-top &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-top-color: transparent; -moz-border-radius:50%; -webkit-border-radius:50%; border-radius:50%;&#125; 四分之三圆-下开口123456789.chart-bottom &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-bottom-color: transparent; -moz-border-radius:50%; -webkit-border-radius:50%; border-radius:50%;&#125; 四分之三圆-左开口123456789.chart-left &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-left-color: transparent; -moz-border-radius:50%; -webkit-border-radius:50%; border-radius:50%;&#125; 四分之三圆-右开口123456789.chart-right &#123; width: 0; height: 0; border: 50px solid yellowgreen; border-right-color: transparent; -moz-border-radius:50%; -webkit-border-radius:50%; border-radius:50%;&#125; 书签12345678.bookmark&#123; width: 0; height: 0; border-top: 50px solid yellowgreen; border-left: 30px solid yellowgreen; border-right: 30px solid yellowgreen; border-bottom: 30px solid transparent;&#125; 有两种方法，这种写法书签的高度是由border-top的宽度50px与border-bottom的宽度30px相加得到的,其实跟CSS之border前言中的第二张图原理是一样的1234567.bookmark2&#123; width: 0; height: 100px; border-left: 50px solid green; border-right: 50px solid yellowgreen; border-bottom: 35px solid transparent;&#125; 这种方法书签的高度是由height确定的，为了便于理解，这里把左右边框颜色做了区分 胶囊12345678.capsule &#123; width: 100px; height: 44px; background: yellowgreen; -moz-border-radius: 22px; -webkit-border-radius: 22px; border-radius: 22px;&#125; 这种方法书签的高度是由height确定的，为了便于理解，这里把左右边框颜色做了区分注：border-radius的取值为高度的一半即可（胶囊其实就是两侧为半圆形，中间为矩形的图形，为实现两侧的半圆形让border-radius的值为高度的一半即半径即可），当宽高交换时即为垂直方向上的胶囊，此处不再列举 半胶囊12345678.capsule-top &#123; width: 40px; height: 60px; background: yellowgreen; -moz-border-radius: 22px 22px 0 0; -webkit-border-radius: 22px 22px 0 0; border-radius: 22px 22px 0 0;&#125; 倾斜半胶囊12345678910111213.capsule-top-r45 &#123; width: 40px; height: 60px; background: yellowgreen; -moz-border-radius: 22px 22px 0 0; -webkit-border-radius: 22px 22px 0 0; border-radius: 22px 22px 0 0; -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); transform: rotate(-45deg);&#125; 其实就是让半胶囊旋转倾斜一定角度 心形心形其实是由半胶囊组成的1234567891011121314151617181920212223242526272829303132333435363738.heart &#123; position: relative;&#125;.heart:before,.heart:after &#123; width: 40px; height: 60px; position: absolute; content: \"\"; left: 50px; top: 0; background: yellowgreen; -moz-border-radius: 50px 50px 0 0; border-radius: 50px 50px 0 0; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-transform-origin: 0 100%; -moz-transform-origin: 0 100%; -ms-transform-origin: 0 100%; -o-transform-origin: 0 100%; transform-origin: 0 100%;&#125;.heart:after &#123; left: 10px; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); -webkit-transform-origin: 100% 100%; -moz-transform-origin: 100% 100%; -ms-transform-origin: 100% 100%; -o-transform-origin: 100% 100%; transform-origin: 100% 100%;&#125; 注：transform-origin设置旋转元素的基点，第一个值为X轴方向向右，第二个值为Y轴方向向下，所以0 100%为以左下角为基点旋转，100% 100%为以右下角为基点旋转当然也可以这么写123456789101112131415161718192021222324252627.heart&#123; position: relative; -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); transform: rotate(-45deg);&#125;.heart::after&#123; content: ''; -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); -webkit-transform: rotate(45deg); transform: rotate(90deg); position: absolute; top: 10px; left: 10px;&#125;.heart,.heart::after &#123; width: 40px; height: 60px; background: yellowgreen; -moz-border-radius: 20px 20px 0 0; -webkit-border-radius: 20px 20px 0 0; border-radius: 20px 20px 0 0;&#125; 旋转心形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051.heart &#123; position: relative; width: 80px; height: 80px; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-transform-origin: 50% 100%; -moz-transform-origin: 50% 100%; -ms-transform-origin: 50% 100%; -o-transform-origin: 50% 100%; transform-origin: 50% 100%; margin: 100px;&#125;.heart:before,.heart:after &#123; width: 40px; height: 60px; position: absolute; content: \"\"; left: 50px; top: 0; background: yellowgreen; -moz-border-radius: 50px 50px 0 0; border-radius: 50px 50px 0 0; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-transform-origin: 0 100%; -moz-transform-origin: 0 100%; -ms-transform-origin: 0 100%; -o-transform-origin: 0 100%; transform-origin: 0 100%;&#125;.heart:after &#123; left: 10px; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); -webkit-transform-origin: 100% 100%; -moz-transform-origin: 100% 100%; -ms-transform-origin: 100% 100%; -o-transform-origin: 100% 100%; transform-origin: 100% 100%;&#125; 其实就是在心形的基础上，让元素旋转一定的角度，即修改transform: rotate()中的值，注旋转时要设置旋转的基点，设置旋转基点前要给元素规定宽高，否则会以整个文档中心为基点进行旋转或者第二种画心形的方法中，直接修改.heart的transform: rotate()值即可这里我就列举了一个例子，想要什么角度的心形，自行修改旋转角度即可得到，就不再一一列举出来了 多角形五角星12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849.star-five &#123; width: 0px; height: 0px; display: block; position: relative; color: #000; border-right: 100px solid transparent; border-bottom: 70px solid yellowgreen; border-left: 100px solid transparent; -moz-transform: rotate(36deg); -webkit-transform: rotate(36deg); -ms-transform: rotate(36deg); -o-transform: rotate(36deg); transform: rotate(36deg);&#125;.star-five:before &#123; content: ''; width: 0; height: 0; display: block; position: absolute; top: -55px; left: -65px; border-bottom: 90px solid yellowgreen; border-left: 30px solid transparent; border-right: 30px solid transparent; -webkit-transform: rotate(-35deg); -moz-transform: rotate(-35deg); -ms-transform: rotate(-35deg); -o-transform: rotate(-35deg); transform: rotate(-35deg);&#125;.star-five:after &#123; content: ''; width: 0px; height: 0px; display: block; position: absolute; top: 3px; left: -106px; border-right: 100px solid transparent; border-bottom: 70px solid yellowgreen; border-left: 100px solid transparent; -webkit-transform: rotate(-72deg); -moz-transform: rotate(-72deg); -ms-transform: rotate(-72deg); -o-transform: rotate(-72deg); transform: rotate(-72deg);&#125; 其实就是两个等腰钝角三角形和一个等腰锐角三角形组合而成，这两个等腰钝角三角形都是由向上三角形（即只显示下边框）旋转各自的度数组成，然后再加上一个向上三角形就成了五角星，把这三个形状分为不同颜色，如下图就可以看出红色和绿色为两个钝角等腰三角形，蓝色的是一个锐角等腰三角形 六角星关于六角星，我们在六角星-上下-覆盖中已经提到过了，就是调整.triangle-tbottom-cover:after的top值即可得到六角星12345678910111213141516171819.star-six &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid yellowgreen; position: relative;&#125;.star-six:after &#123; content: \" \"; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid yellowgreen; position: absolute; top: 33px; left: -50px;&#125; 八角星12345678910111213141516171819202122232425.star-eight &#123; width: 80px; height: 80px; background: yellowgreen; position: relative; -webkit-transform: rotate(20deg); -moz-transform: rotate(20deg); -ms-transform: rotate(20deg); -o-transform: rotate(20eg); transform: rotate(20deg);&#125;.star-eight:before &#123; content: \"\"; width: 80px; height: 80px; background: yellowgreen; position: absolute; top: 0; left: 0; -webkit-transform: rotate(135deg); -moz-transform: rotate(135deg); -ms-transform: rotate(135deg); -o-transform: rotate(135deg); transform: rotate(135deg);&#125; 即两个正方形旋转一定，角度然后叠加在一起 十二角星123456789101112131415161718192021222324252627282930.star-twelve&#123; width: 80px; height: 80px; background: yellowgreen; position: relative; &#125; .star-twelve:before, .star-twelve:after&#123; content: \"\"; width: 80px; height: 80px; background: yellowgreen; position: absolute; top: 0; left: 0; &#125; .star-twelve:after &#123; -webkit-transform: rotate(20deg); -moz-transform: rotate(20deg); -ms-transform: rotate(20deg); -o-transform: rotate(20eg); transform: rotate(30deg); &#125; .star-twelve:before &#123; -webkit-transform: rotate(135deg); -moz-transform: rotate(135deg); -ms-transform: rotate(135deg); -o-transform: rotate(135deg); transform: rotate(60deg); &#125; 很明显就是有3个正方形旋转一定角度，然后叠加而成的，后面的就以此类推了，都是由基础图形旋转叠加所得 多边形五边形123456789101112131415161718.pentagon &#123; position: relative; width: 54px; border-top: 50px solid yellowgreen; border-right: 18px solid transparent; border-left: 18px solid transparent;&#125;.pentagon:before &#123; content: \"\"; width: 0; height: 0; position: absolute; top: -85px; left: -18px; border-right: 45px solid transparent; border-left: 45px solid transparent; border-bottom: 35px solid yellowgreen;&#125; 六边形12345678910111213141516171819202122232425262728.hexagon &#123; width: 100px; height: 55px; background: yellowgreen; position: relative;&#125;.hexagon:before &#123; content: \"\"; width: 0; height: 0; position: absolute; top: -25px; left: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 25px solid yellowgreen;&#125;.hexagon:after &#123; content: \"\"; width: 0; height: 0; position: absolute; bottom: -25px; left: 0; border-top: 25px solid yellowgreen; border-left: 50px solid transparent; border-right: 50px solid transparent;&#125; 上面这个例子是由两个三角形和一个矩形组成的，下面这个例子是由两个梯形组成的，它们得到的效果是相同的，都是上面这个图12345678910111213141516171819.hexagon &#123; width: 0; height: 50px; border-top: 25px solid transparent; border-right: 50px solid yellowgreen; border-bottom: 25px solid transparent; position: relative;&#125;.hexagon:before &#123; content: \"\"; width: 0; height: 50px; position: absolute; top: -25px; left: 50px; border-top: 25px solid transparent; border-left: 50px solid yellowgreen; border-bottom: 25px solid transparent;&#125; 有趣的是调整.hexagon:before的top和left会得到不同的效果，例如当设置top和left均为0时会组成平行四边形当设置top:-25px;left:0;时，会组成下面的图形 八边形12345678910111213141516171819202122232425262728.octagon &#123; width: 100px; height: 37px; background: yellowgreen; position: relative;&#125;.octagon:before &#123; content: \"\"; width: 42px; height: 0; position: absolute; top: -31px; left: 0; border-bottom: 31px solid yellowgreen; border-left: 29px solid transparent; border-right: 29px solid transparent;&#125;.octagon:after &#123; content: \"\"; width: 42px; height: 0; position: absolute; top: 37px; left: 0; border-top: 31px solid yellowgreen; border-left: 29px solid transparent; border-right: 29px solid transparent;&#125; 由两个梯形和一个矩形组成，一次类推，其实多边形的实现都是由简单的三角形、矩形、梯形旋转堆叠而成的 鸡蛋12345678.egg &#123; width: 75px; height: 100px; display: block; background-color: yellowgreen; -webkit-border-radius: 38px 38px 38px 38px / 60px 60px 40px 40px; border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;&#125; 注：border-radius中前四个值是四个角在width的基础上的圆角度值，/之后的四个值是四个角在height的基础上的圆角度值 钻石12345678910111213141516171819.diamond &#123; width: 50px; height: 0; border-right: 25px solid transparent; border-left: 25px solid transparent; border-bottom: 25px solid yellowgreen; position: relative;&#125;.diamond:after &#123; content: \"\"; width: 0; height: 0; position: absolute; top: 25px; left: -25px; border-top: 70px solid yellowgreen; border-right: 50px solid transparent; border-left: 50px solid transparent;&#125; 很简单，跟多边形的原理一样，就是由一个梯形和一个三角形组成 无穷大12345678910111213141516171819202122232425262728293031323334.infinity &#123; width: 212px; height: 100px; position: relative;&#125;.infinity:before,.infinity:after &#123; content: \"\"; width: 60px; height: 60px; position: absolute; top: 0; left: 0; border: 20px solid yellowgreen; -moz-border-radius: 50% 50% 0 50%; border-radius: 50% 50% 0 50%; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg);&#125;.infinity:after &#123; left: auto; right: 0; border: 20px solid yellowgreen; -moz-border-radius: 50% 50% 50% 0; border-radius: 50% 50% 50% 0; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg);&#125; 由两个分别右下角和左下角圆角弧度为0，其它角弧度均为50%的矩形旋转一定的角度组成而得，或许区别一下.infinity:before和.infinity:after的边框颜色，会看的更明显 八卦1234567891011121314151617181920212223242526272829303132.gossip &#123; width: 96px; height: 48px; background: white; border-color: black; border-style: solid; border-width: 2px 2px 50px 2px; border-radius: 50%; position: relative;&#125;.gossip:before &#123; content: \"\"; width: 12px; height: 12px; position: absolute; top: 50%; left: 0; background: white; border: 18px solid black; border-radius: 50%;&#125;.gossip:after &#123; content: \"\"; position: absolute; top: 50%; left: 50%; background: black; border: 18px solid white; border-radius: 50%; width: 12px; height: 12px;&#125; 从下面这张图可以看出，其实这个八卦图是由一个底边框为50%，其它边框为2px的圆和两个宽高均为12px且都18px边框包围的圆组成总结：通过这么多图形，我们不难发现，其实很多看起来很复杂的形状都是由最初的简单的形状通过旋转组合而成的，在实现这些图形的过程中，我也有很多发现，很多时候不经意间的调整某个值，会发生意想不到的效果。这里仅仅列举了一部分，我相信肯定还有更多好玩的有趣的图形等待我们发现，你还有哪些图形，可以在评论区留言，大家一起讨论学习一下最后，本篇文章是由二蛋的前端博客：http://yyeggs.com//CSS_border_graph/ 整理的，其中有很多都是我在整理的时候意外发现的，也有很多我自己的理解和解释，所以转载请注明，另外这里的部分代码整理于http://www.itivy.com/ivy/archive/2012/1/16/css-shape.html 也请同样注明","tags":[{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"},{"name":"border","slug":"border","permalink":"http://yyeggs.com/tags/border/"}]},{"title":"PS保存成svg格式","date":"2018-10-22T09:34:31.000Z","path":"save_ps_svg/","text":"安装脚本下载save-ps-to-svg1.0.jsx脚本，并放到PS的安装目录/Presets/Scripts文件夹下，如图所示 绘制svg图形打开PS，使用形状工具绘图，（注：只有形状图层才可以保存为svg格式），并给该图层命名为xx.svg 保存为svg先保存psd格式文件，然后点击文件-&gt;脚本-&gt;Save as svg，即可在该psd同目录的文件夹下发现.svg格式的文件","tags":[{"name":"svg","slug":"svg","permalink":"http://yyeggs.com/tags/svg/"},{"name":"ps","slug":"ps","permalink":"http://yyeggs.com/tags/ps/"}]},{"title":"JS通用事件侦听器函数","date":"2018-10-22T07:11:11.000Z","path":"JS_addEventListener_event/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// JS通用事件侦听器函数 var EventUtil = &#123; // 页面加载完成之后执行 readyEvent: function (fn) &#123; if (document.addEventListener) &#123;//标准浏览器 document.addEventListener('DOMContentLoaded', function () &#123; document.removeEventListener('DOMContentLoaded', arguments.callee, false);//注销事件，避免反复触发 fn();// 执行函数 &#125;, false); &#125; else if (document.attachEvent) &#123;// IE浏览器 document.attachEvent('onreadystatechange', function () &#123; if (document.readyState == 'complete') &#123;//加载完成 document.detachEvent('onreadystatechange', arguments.callee); fn();//执行函数 &#125; &#125;); &#125; &#125;, /* *attachEvent可以使用匿名函数，但这样之后，detachEvent将无法卸载它。 *detachEvent所卸载的函数必须使用函数名。 */ //添加事件 addEvent:function(element,type,fn)&#123; if(element.addEventListener)&#123;// 标准浏览器 element.addEventListener(type,fn,false);//事件类型、需要执行的函数、是否捕获 &#125;else if(element.attachEvent)&#123;//IE浏览器 element.attachEvent('on'+type,fn); &#125;else&#123; element['on'+type]=fn;//DOM0 &#125; &#125;, //移除事件 removeEvent:function(element,type,fn)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,fn,false); &#125;else if(element.detachEvent)&#123; element.detachEvent('on'+type,fn); &#125;else&#123; element['on'+type]=null; &#125; &#125;, //阻止事件冒泡（主要是阻止冒泡，因为IE不支持事件捕获，用于停止事件在DOM层中传播，即进一步取消事件的捕获或者冒泡） stopPropagation:function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation();//标准浏览器 &#125;else&#123; event.cancelBubble=ture;//IE &#125; &#125;, //阻止事件默认行为（如url跳转等） preventDefault:function(event)&#123; if(event.preventDefault)&#123; event.preventDefaule();//标准浏览器 &#125;else&#123; event.returnValue=false;//IE &#125; &#125;, //获取event对象的引用，获取事件的所有信息，确保随时能使用event getEvent:function(event)&#123; var event=event||window.event;//在DOM0级事件添加，event作为window对象的一个属性存在 &#125;, //获取事件目标 getTarget:function(event)&#123; return event.target||event.srcElement; &#125; &#125;;","tags":[{"name":"JS","slug":"JS","permalink":"http://yyeggs.com/tags/JS/"}]},{"title":"CSS之border详解","date":"2018-10-15T08:24:57.000Z","path":"CSS_border/","text":"border是用来规定元素边框的样式，有三种默认属性：border-width(边框宽度)、border-style(边框样式)、border-color(边框颜色)，这三种属性都可以分开来写，同时CSS3还新加入了border-radius(圆角度)和border-image(边框背景图)，下面我们就分别来了解一下各个样式属性的取值和说明等 border-width 边框宽度border-width分四个属性：border-top-widht、border-right-width、border-bottom-width、border-left-width取值： &lt;length&gt;:用长度值来定义边框的厚度，非负值 medium:定义默认厚度的边框，值为3px thin:定义比默认厚度细的边框，值为1px thick:定义比默认厚度粗的边框，值为5px说明：4个值：按上、右、下、左的顺序分别作用于四个边3个值：第一个值作用于上，第二个值作用于左右，第三个值作用于下2个值：第一个作用于上下，第二个值作用于左右1个值：同时作用于四个边 border-style 边框样式border-style分四个属性：border-top-style、border-right-style、border-bottom-style、border-left-style取值： none:无轮廓,该值情况下border-color将不起作用，border-width取值为0，除非边框轮廓为图像，即border-image hidden:隐藏边框,IE7及以下不支持 dotted:点状轮廓，IE6下显示为dashed效果 dashed:虚线轮廓 solid:实线轮廓 double:双线轮廓，两条单线与其间隔之和等于指定的border-width的值 groove:3D凹槽轮廓 ridge:3D凸槽轮廓 inset:3D凹边轮廓 outset:3D凸边轮廓说明：4个值：按上、右、下、左的顺序分别作用于四个边3个值：第一个值作用于上，第二个值作用于左右，第三个值作用于下2个值：第一个作用于上下，第二个值作用于左右1个值：同时作用于四个边 border-color 边框颜色border-color也跟前上面两个一样分上、右、下、左四个属性取值： &lt;color&gt;:指定颜色（transparent:透明）说明：4个值：按上、右、下、左的顺序分别作用于四个边3个值：第一个值作用于上，第二个值作用于左右，第三个值作用于下2个值：第一个作用于上下，第二个值作用于左右1个值：同时作用于四个边 border-radius 圆角度border-radius分四个属性：border-top-left-radius(左上角))、border-top-right-radius(右上角)、border-bottom-right-radius(右下角)、border-bottom-left-radius(左下角)取值：&lt;length&gt;:用长度设置对象的圆角半径长度，非负数&lt;percentage&gt;:用百分比设置对象的圆角半径长度说明：设置或检索对象使用圆角边框。提供2个参数，2个参数以“/”分隔，每个参数允许设置1~4个参数值，第1个参数表示水平半径，第2个参数表示垂直半径，若第2个参数省略，则默认等于第1个参数水平半径：4个值：按top-left(左上角)、top-right(右上角)、bottom-right(右下角)、bottom-left(左下角)顺序分别作用于四个角3个值：第一个值作用于top-left(左上角)，第二个值作用于top-right(右上角)和bottom-left(左下角)，第三个值作用于bottom-right(右下角)2个值：第一个值作用于top-left(左上角)和bottom-right(右下角)，第二个值作用于top-right(右上角)和bottom-left(左下角)1个值：同时作用于全部4个角注：如果想让2个值的时候表示相邻的两个角而不是对角，可以这样写：border-radius:&lt;length&gt;/&lt;length&gt;，其中第一个值表示左上角和右上角，第二个值表示右下角和左下角垂直半径同上 border-image 边框背景图border-image分五个属性：border-image-source、border-image-slice、border-image-width、border-image-outset、border-image-repeat取值：border-image-source：设置或检索对象的边框是否用图像定义样式或图像来源路径border-image-slice：设置或检索对象的边框背景图的分割方式border-image-width：设置或检索对象的边框厚度border-image-outset：设置或检索对象的边框背景图的扩展border-image-repeat：设置或检索对象的边框图像的平铺方式说明：当此属性不生效或图片未加载成功时，border-style就会生效 box-shadow 边框阴影取值：none:无阴影&lt;length&gt;：第1个长度值–阴影水平偏移值，方向：右&lt;length&gt;：第2个长度值–阴影垂直偏移值，方向：下&lt;length&gt;：第3个长度值–阴影模糊值，非负数，可选&lt;length&gt;：第4个长度值–阴影外延值，可为负，可选&lt;color&gt;：阴影颜色inset：阴影类型为内阴影，（当无此值时，默认为外阴影）说明：可以设置多组效果，每组以逗号分隔，应用顺序与上面相同 总结本篇主要针对CSS的border属性进行详解，其实我写这篇博客的主要目的是为后面的用border属性写各种对话气泡和各种图形做铺垫，感兴趣的话可以多多关注哦！","tags":[{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"},{"name":"border","slug":"border","permalink":"http://yyeggs.com/tags/border/"}]},{"title":"多栏布局（二）--上下栏布局","date":"2018-10-10T07:46:38.000Z","path":"Multi_Column_Layout_tb/","text":"1 上固定，下自适应1.1 absolute 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; height: 100px; background: red; &#125; .bottom &#123; position: absolute; top: 100px; bottom: 0; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p&#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt; 1.2 absolute-fixed 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; height: 100px; background: red; &#125; .bottom &#123; position: fixed; top: 100px; bottom: 0; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p&#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt; 1.3 fixed-absolute 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: fixed; top: 0; height: 100px; background: red; &#125; .bottom &#123; position: absolute; top: 100px; bottom: 0; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p&#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt; 其实就是用定位实现，方案1全是绝对定位absolute，方案2和方案3就是一个是绝对定位absolute另一个是固定定位fixed；后面的下固定，上自适应和上下自适应，中间自适应也是相同的道理。是不是很简单 2 下固定，上自适应2.1 absolute 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; bottom: 100px; overflow: auto; background: yellowgreen; &#125; .bottom &#123; position: absolute; bottom: 0; height: 100px; background: red; &#125; /* 查看滚动效果 */ div p&#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 2.2 absolute-fixed 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: fixed; top: 0; bottom: 100px; overflow: auto; background: yellowgreen; &#125; .bottom &#123; position: absolute; bottom: 0; height: 100px; background: red; &#125; /* 查看滚动效果 */ div p &#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 2.3 fixed-absolute 解决方案1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; bottom: 100px; overflow: auto; background: yellowgreen; &#125; .bottom &#123; position: fixed; bottom: 0; height: 100px; background: red; &#125; /* 查看滚动效果 */ div p &#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"top\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 3 上下固定，中间自适应3.1 absolute 解决方案12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; height: 100px; background: yellow; &#125; .bottom &#123; position: absolute; bottom: 0; height: 100px; background: red; &#125; .center&#123; position: absolute; top: 100px; bottom: 100px; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p &#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"center\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 3.2 absolute-fixed 解决方案12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: absolute; top: 0; height: 100px; background: yellow; &#125; .bottom &#123; position: absolute; bottom: 0; height: 100px; background: red; &#125; .center&#123; position: fixed; top: 100px; bottom: 100px; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p &#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"center\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 3.3 fixed-absolute 解决方案12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; html,body &#123; margin: 0; padding: 0; height: 100%; overflow: hidden; &#125; div &#123; width: 100%; &#125; .top &#123; position: fixed; top: 0; height: 100px; background: yellow; &#125; .bottom &#123; position: fixed; bottom: 0; height: 100px; background: red; &#125; .center&#123; position: absolute; top: 100px; bottom: 100px; overflow: auto; background: yellowgreen; &#125; /* 查看滚动效果 */ div p &#123; height: 300px; line-height: 300px; &#125;&lt;/style&gt;&lt;div class=\"top\"&gt;&lt;/div&gt;&lt;div class=\"center\"&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;&lt;/div&gt; 需要注意的一点就是，这种布局，一般都会设置html和body高度100%，并且溢出隐藏overflow:hidden;而自适应的用来放内容的那一部分设置溢出自适应overflow:auto;这样滚动条就会出现在这一部分，而不是整个页面","tags":[{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yyeggs.com/tags/html/"}]},{"title":"多栏布局（一）-- 左右栏布局","date":"2018-10-03T10:58:47.000Z","path":"Multi_Column_Layout_lr/","text":"1 左固定，右自适应1.1 浮动解决方案123456789101112131415161718192021222324252627282930&lt;style&gt; html,body&#123; margin: 0; padding:0; &#125; div&#123; min-height: 100px; &#125; .left &#123; float: left; width: 300px; background: red; &#125; .right &#123; margin-left: 300px; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 注：上面.right 的 margin-left 属性可以用 overflow:hidden 来替代（让.right 开启 BFC）否则当右侧高度过大时，会出现如下效果： 特点：两栏高度不一致优点：兼容性好缺点：浮动元素过多会导致页面结构复杂，并且要清除浮动，否则会导致页面混乱 1.2 定位解决方案1.2.1 定位解决方案 1123456789101112131415161718192021222324252627282930313233&lt;style&gt; html,body&#123; margin: 0; padding:0; &#125; div&#123; min-height: 100px; &#125; .wrap&#123; position: relative; &#125; .left &#123; position: absolute; width: 300px; background: red; &#125; .right &#123; margin-left: 300px; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;定位解决方案1 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1.2.2 定位解决方案 212345678910111213141516171819202122232425262728293031323334353637383940&lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; position: relative; &#125; .left &#123; position: absolute; width: 300px; background: red; &#125; .right &#123; position: absolute; left: 300px; right: 0; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;定位解决方案2 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 特点：两栏高度不一致优点：兼容性好缺点：脱离文档流，增加页面结构的复杂程度 1.3 table 解决方案123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: table; width: 100%; &#125; .left &#123; display: table-cell; width: 300px; background: red; &#125; .right &#123; display: table-cell; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;table解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致 1.4 flex 解决方案12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: flex; &#125; .left &#123; width: 300px; background: red; &#125; .right &#123; flex: 1; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;flex解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致优点：CSS3 新属性，实现简单缺点：兼容性差 1.5 grid 解决方案123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: grid; grid-template-columns: 300px auto; &#125; .left &#123; background: red; &#125; .right &#123; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;grid解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致优点：CSS3新属性，实现简单缺点：兼容性差 2 右固定，左自适应2.1 浮动解决方案123456789101112131415161718192021222324252627282930&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .left &#123; background: yellowgreen; margin-right: 300px; &#125; .right &#123; float: right; width: 300px; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"right\"&gt;&lt;/div&gt; 注：上面.left 的 margin-right 属性可以用 overflow:hidden 来替代（让.left 开启 BFC） 在页面结构上，必须让固定的元素位于自适应的元素之前，否则若自适应的元素在前，因为其为块级元素，盒模型将会占一整行的宽度，这样固定的元素就会被挤到下面，页面结构就会混乱，如下图；而固定的元素在前，因为其设置了浮动，所以脱离了文档流，且z-index级别比文档流高，所以会压在自适应的元素之上特点：两栏高度不一致优点：兼容性好缺点：浮动元素过多会导致页面结构复杂，并且要清除浮动，否则会导致页面混乱 2.2 定位解决方案2.2.1 定位解决方案 11234567891011121314151617181920212223242526272829303132333435&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; position: relative; &#125; .left &#123; margin-right: 300px; background: yellowgreen; &#125; .right &#123; position: absolute; right: 0; top:0; width: 300px; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;定位解决方案1 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 注：定位解决方案1中，在页面结构上，固定的右侧栏也必须在自适应的左侧栏之前，理由同上，其左侧栏.left同样没有脱离文档流 2.2.2 定位解决方案 2123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; position: relative; &#125; .left &#123; position: absolute; left: 0; right: 300px;; background: yellowgreen; &#125; .right &#123; position: absolute; right: 0; width: 300px; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;定位解决方案2 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 特点：两栏高度不一致优点：兼容性好缺点：脱离文档流，增加页面结构的复杂程度 2.3 table 解决方案12345678910111213141516171819202122232425262728293031323334&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: table; width: 100%; &#125; .left &#123; display: table-cell; background: yellowgreen; &#125; .right &#123; display: table-cell; width: 300px; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致 2.4 flex 解决方案1234567891011121314151617181920212223242526272829303132&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: flex; &#125; .left &#123; flex: 1; background: yellowgreen; &#125; .right &#123; width: 300px; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致优点：CSS3 新属性，实现简单缺点：兼容性差 2.5 grid 解决方案12345678910111213141516171819202122232425262728293031&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: grid; grid-template-columns: auto 300px; &#125; .left &#123; background: yellowgreen; &#125; .right &#123; background: red; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：两栏高度一致优点：CSS3新属性，实现简单缺点：兼容性差 3 左右固定，中间自适应3.1 浮动解决方案12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .left &#123; float: left; width: 300px; background: yellow; &#125; .right &#123; float: right; width: 300px; background: red; &#125; .center &#123; margin-left: 300px; margin-right: 300px; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 注：上面.center 的 margin 属性可以用 overflow:hidden 来替代（让.center 开启 BFC） 在页面结构上，在页面结构上，固定的两侧栏在前，自适应的中间栏在后，原因见上面右固定，左自适应的浮动解决方案特点：三栏高度不一致优点：兼容性好缺点：浮动元素过多会导致页面结构复杂，并且要清除浮动，否则会导致页面混乱 3.2 定位解决方案3.2.1 定位解决方案1123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; position: relative; &#125; .left &#123; position: absolute; left: 0; width: 300px; background: yellow; &#125; .right &#123; position: absolute; right: 0; width: 300px; background: red; &#125; .center &#123; margin-left: 300px; margin-right: 300px; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;定位解决方案1 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 注：定位解决方案1中，在页面结构上，固定的两侧栏在前，自适应的中间栏在后，原因见上面右固定，左自适应的浮动解决方案 3.2.2 定位解决方案212345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; position: relative; &#125; .left &#123; position: absolute; left: 0; width: 300px; background: yellow; &#125; .right &#123; position: absolute; right: 0; width: 300px; background: red; &#125; .center &#123; position: absolute; left: 300px; right: 300px; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：三栏高度不一致优点：兼容性好缺点：脱离文档流，增加页面结构的复杂程度 3.3 table 解决方案12345678910111213141516171819202122232425262728293031323334353637383940&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: table; width: 100%; &#125; .left &#123; display: table-cell; width: 300px; background: yellow; &#125; .right &#123; display: table-cell; width: 300px; background: red; &#125; .center &#123; display: table-cell; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：三栏高度一致 3.4 flex 解决方案12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: flex; &#125; .left &#123; width: 300px; background: yellow; &#125; .right &#123; width: 300px; background: red; &#125; .center &#123; flex: 1; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：三栏高度一致优点：CSS3 新属性，实现简单缺点：兼容性差 3.5 grid 解决方案1234567891011121314151617181920212223242526272829303132333435&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; div &#123; min-height: 100px; &#125; .wrap &#123; display: grid; grid-template-columns: 300px auto 300px; &#125; .left &#123; background: yellow; &#125; .right &#123; background: red; &#125; .center &#123; background: yellowgreen; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt;浮动解决方案 我宽度自适应我宽度自适应我宽度自适应 &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;p&gt;增加高度&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 特点：三栏高度一致优点：CSS3新属性，实现简单缺点：兼容性差 4 总结其实不管是谁固定，谁自适应，可以看到都是通过浮动、定位、table、flex、grid这5种方法实现的，只要掌握好这5种方法，可以应对以上三种布局方式","tags":[{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yyeggs.com/tags/html/"}]},{"title":"居中问题（三） -- 水平垂直居中","date":"2018-09-11T12:13:38.000Z","path":"Center_Horizontal_Vertical/","text":"鉴于实际需求，这里只列举了块级元素内的块级元素水平垂直居中，如果你想要实现块级元素内的行内元素或类行内元素居中，请参考前两篇的水平居中和垂直居中的博客 1 水平垂直居中1.1 margin1234567891011121314151617181920212223&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; border: 1px solid transparent; background: paleturquoise; &#125; .in &#123; width: 100px; height: 100px; margin-top: 50px; margin-left: 50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：.in的margin-left值为(.wrap的宽度-.in的宽度)/2；.in的margin-top值为(.wrap的高度-.in的高度)/2；值得注意的是我在.wrap上添加了一个border: 1px solid transparent;属性，目的是为了解决边距重叠问题，关于边距重叠问题，我后续也会专门写一篇博客来详细介绍，有兴趣的小伙伴可以继续关注哦！ 优点：最简单的实现方式，兼容各种浏览器缺点：可扩展性低，内盒子的宽高必须固定，且每当改变内外盒子的宽高，margin值都要重新计算 1.2 定位 position1234567891011121314151617181920212223242526&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：最常用的实现方式，兼容性好，可以同时实现水平和垂直居中缺点：内盒子的宽高必须固定 1.3 定位 position–margin12345678910111213141516171819202122232425262728&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; height: 100px; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：定位方式的一种，我们都知道当定位的元素同时设置了top、right、bottom和left值时只有top和left起作用，但当加上margin:auto这点睛之笔后，你会发现这四个值都会起作用，而当这四个值都是0时就实现了我们现在的水平垂直居中了，怎么样？神不神奇 优点：兼容性好，可以同时实现水平垂直居中，且宽度无须固定缺点：高度必须固定，否则将占父元素的100% 1.4 定位position结合transform1.4.1 absolute–transform1234567891011121314151617181920212223242526&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; /* height: 100px;*/ position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：弥补了1.2中的缺点，内盒子宽高可以不固定，当内盒子宽高固定时，translate()括号中的值为负的内盒子宽/高的二分之一即可，即相当于1.2中的margin-left/top，而不论内盒子宽高是否固定，translate()括号中的值都可以是两个-50%。注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d;具体关于CSS3的动画属性，我后续也会专门写一篇博客进行介绍，有兴趣的小伙伴，可以一起讨论讨论哦 优点：实现简单，宽高无须固定缺点：transform是CSS3的新属性，所以兼容性比较差 1.4.2 relative–transform12345678910111213141516171819202122232425&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; /* height: 100px;*/ position: relative; top: 50%; left: 50%; transform: translate(-50%,-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：这个方法与1.4.1极相似，不同之处在于，此法外盒子不定位，直接给内盒子采取相对定位relative，但一般使用率比较低注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d; 1.5 table-cell123456789101112131415161718192021222324&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; display: table-cell; vertical-align: middle; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; /* height: 100px;*/ margin: 0 auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：实现简单，内盒子宽高无须固定缺点：table-cell会跟浮动、定位等属性相互冲突，并且不能设置margin属性 1.6 flex1.6.1 align-items123456789101112131415161718192021222324&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; /* height: 100px;*/ background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：justify-content:center;意为flex主轴方向对齐方式：居中，而align-items: center;意为交叉轴方向对齐方式：居中。主轴方向flex-direction默认为row即横向，则交叉轴即为纵向，也就是垂直方向关于flex可以参考我的博客 优点：实现简单，内盒子宽高无须固定缺点：flex为CSS3新属性，兼容性差，且flex内的元素float、clear、vertical-align等样式全部失效 1.6.2 align-self123456789101112131415161718192021222324&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; display: flex; justify-content: center; background: paleturquoise; &#125; .in &#123; /* width: 100px; */ width: fit-content; /* height: 100px;*/ align-self: center; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：这个方法跟上一个很相似，唯一不一样的地方就在于上一个方法用align-items属性，而这个方法用的是align-self属性。简单说一下两个属性的区别：align-items属性是容器即外盒子的属性，意为容器内所有元素的交叉轴对齐方式；而align-self属性是内元素属性，意为本元素的交叉轴对齐方式 1.7 calc()12345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; border: 1px solid transparent; background: paleturquoise; &#125; .in &#123; width: 100px; height: 100px; margin: calc(50% - 50px) auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：前面那个50%取值是父元素高度的50%，后面那个50px取值是本元素的高的一半，其实原理跟1.1的margin是相同的注：不要质疑calc()就是一个CSS3属性，是用来指定长度的，比如可以给元素的width、height、border、margin、padding、font-size等属性设置动态值，但一定要注意calc()括号中的运算符前后一定要有空格！运算符前后一定要有空格！运算符前后一定要有空格！（重要的事情说三遍） 优点：当页面结构复杂无法用其它方式实现水平垂直居中时，你会非常喜欢这个属性的缺点：CSS3新属性，兼容性还不是很好，而且在css中进行计算会降低页面性能 2 总结关于我所了解的水平居中、垂直居中、水平垂直居中的各种方法到这里就介绍完毕了，如果小伙伴们还有其它方法，或者在具体的实践中遇到任何问题，都欢迎大家在评论区积极讨论，我也会一直关注的哦✌","tags":[{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yyeggs.com/tags/html/"}]},{"title":"居中问题（二） -- 垂直居中","date":"2018-09-01T07:02:16.000Z","path":"Center_Vertical/","text":"1 行内元素内容居中12345678910111213&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; span&#123; padding: 5px 8px; float: left; background: plum; &#125;&lt;/style&gt;&lt;span&gt;请叫我小仙女&lt;/span&gt; 说明：大多数行内元素不能设置宽高，只能由内容撑起，而若要实现上下左右有空隙则需设置padding，但是行内元素的padding只对左、右、下起作用，margin只对左、右起作用，所以对于行内元素若想让上述属性起作用，则需设置浮动或定位，而若要垂直方向居中则设置padding-top=padding-bottom即可 优点：简单、常用，可同时实现水平垂直居中，兼容性好缺点：需要设置浮动或定位来辅助实现 2 块级元素中的行内元素或类行内元素居中2.1 line-height1234567891011121314151617181920&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; line-height: 200px; background: paleturquoise; &#125; span &#123; background: plum; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;span&gt;请叫我小仙女&lt;/span&gt; &lt;img src=\"images/eg_cute.gif\" alt=\"\"&gt;&lt;/div&gt; 说明：外盒子设置line-height=height即可 优点：简单、常用，兼容性好缺点：若需要居中的内容为多行则不适用 2.2 vertical-align12345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; display: table-cell; vertical-align: middle; background: paleturquoise; &#125; span &#123; background: plum; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"wrap\"&gt; &lt;span&gt;请叫我小仙女请叫我小仙女请叫我小仙女&lt;/span&gt; &lt;/div&gt; 说明：在没有其它属性辅助的情况下，只有table-cell属性的元素才可以使用vertical-align属性 优点：可同时适用于单行和多行内容缺点：实现条件苛刻 2.3 flex1234567891011121314151617181920&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; display: flex; align-items: center; background: paleturquoise; &#125; span &#123; background: plum; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;span&gt;请叫我小仙女小仙女小仙女小仙女&lt;/span&gt;&lt;/div&gt; 优点：可同时适用于单行和多行内容缺点：CSS3新属性，兼容性差 3 块级元素3.1 margin123456789101112131415161718192021&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; border: 1px solid transparent; background: paleturquoise; &#125; .in &#123; height: 100px; margin-top: 50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：.in的margin-top值为(.wrap的高度-.in的高度)/2；值得注意的是我在.wrap上添加了一个border: 1px solid transparent;属性，目的是为了解决边距重叠问题，关于边距重叠问题，我后续也会专门写一篇博客来详细介绍，有兴趣的小伙伴可以继续关注哦！ 优点：最简单的实现方式，兼容各种浏览器缺点：可扩展性低，内盒子的高度必须固定，且每当改变内外盒子的高度，margin-top的值都要重新计算 3.2 定位position1234567891011121314151617181920212223&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in &#123; height: 100px; position: absolute; top: 50%; margin-top: -50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：最常用的实现方式，兼容性好，可以在此基础上以同样方法添加left和margin-left实现水平垂直居中缺点：内盒子的高度必须固定 3.3 定位position结合transform3.3.1 absolute–transform1234567891011121314151617181920212223&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in &#123; /* height: 100px; */ position: absolute; top: 50%; transform: translateY(-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d;优点：弥补了3.2中的缺点，内盒子高度可以不固定，当内盒子高度固定时，translateY()括号中的值为负的内盒子高的二分之一即可，即相当于3.2中的margin-top，而不论内盒子高度是否固定，translateY()括号中的值都可以是-50%缺点：transform是CSS3的新属性，所以兼容性比较差 3.3.2 relative–transform12345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in &#123; height: 100px; position: relative; top: 50%; transform: translateY(-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：这个方法与3.3.1极相似，不同之处在于，此法外盒子不定位，直接给内盒子采取相对定位relative，但一般不会这样使用，都是采用上面那种方法注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d; 3.4 :before结合inline-block结合vertical-align1234567891011121314151617181920212223242526&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; background: paleturquoise; &#125; .wrap::before&#123; content:\"\"; display:inline-block; height:100%; vertical-align:middle; &#125; .in &#123; display: inline-block; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 缺点：实现起来比较麻烦，所以很少用 3.5 flex123456789101112131415161718192021&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; display: flex; align-items: center; background: paleturquoise; &#125; .in &#123; /* height: 100px; */ background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：align-items:center;意为交叉轴方向对齐方式：居中。主轴方向flex-direction默认为row即横向，则交叉轴即为纵向，也就是垂直方向关于flex可以参考我的博客 优点：实现简单，内盒子高度无须固定缺点：flex为CSS3新属性，兼容性差，且flex内的元素float、clear、vertical-align等样式全部失效 3.6 增加节点1234567891011121314151617181920212223&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 200px; height: 200px; background: paleturquoise; &#125; .hide&#123; height: 50px; &#125; .in &#123; height: 100px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"hide\"&gt;&lt;/div&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：在内盒子前添加一个元素，并且设置高度为内外盒子高度差的二分之一，宽度默认100%即可,其实这种方法跟3.1原理是相同的，此处.hide的位置即为3.1中margin-top所占据的位置 优点：请原谅我从宏观上看并没有发现此方法的优点，但不代表这种方法没有用，或许在某些复杂或奇怪的页面结构中，其它方法都不适用，只能采用这种方法呢缺点：需要增加元素节点，且内盒子高度必须固定 4 总结关于垂直居中的方法就总结到这里了，如果小伙伴们还有其它方法，或者在具体的实践中遇到任何问题，都欢迎大家在评论区积极讨论，我也会一直关注的哦✌","tags":[{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yyeggs.com/tags/html/"}]},{"title":"居中问题（一） -- 水平居中","date":"2018-08-16T03:22:40.000Z","path":"Center_Horizontal/","text":"对于行内元素的内容居中，因为行内元素一般都不能设置宽高，而是由内容撑起的，可以设置padding值，所以这里的居中问题考虑的是块级元素内的元素水平居中，而不考虑行内元素内的元素或内容居中 1 行内或类行内元素（比如图片、文本、链接等）居中12345678910111213141516&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; text-align: center; background: paleturquoise; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;span&gt;请叫我小仙女&lt;/span&gt;&lt;/div&gt; 块级父容器设置text-align: center; 2 块级元素居中2.1 margin1234567891011121314151617181920&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in&#123; width: 100px; margin-left: 50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 说明：.in的margin-left值为(.wrap的宽度-.in的宽度)/2 优点：最简单的实现方式，兼容各种浏览器缺点：可扩展性低，内盒子的宽度必须固定，且每当改变内外盒子的宽度，margin-left的值都要重新计算 2.2 margin–auto123456789101112131415161718192021&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; margin: 0 auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：最简单、常用的实现方式，兼容各种浏览器，并且当内盒子的宽度不固定时（例如上面width:fit-content（宽度收缩到内容））也同样适用缺点：此属性只能实现水平居中，不能像定位属性那样可以同时实现水平垂直居中 2.3 定位position1234567891011121314151617181920212223&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in&#123; width: 100px; position: absolute; left: 50%; margin-left: -50px; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：最常用的实现方式，兼容性好，可以在此基础上以同样方法添加top和margin-top实现水平垂直居中缺点：内盒子的宽度必须固定 2.4 定位position结合transform2.4.1 absolute–transform123456789101112131415161718192021222324&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; position: relative; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; position: absolute; left: 50%; transform: translateX(-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d;优点：弥补了2.3中的缺点，内盒子宽度可以不固定，当内盒子宽度固定时，translateX()括号中的值为负的内盒子宽的二分之一即可，即相当于2.3中的margin-left，而不论内盒子宽度是否固定，translateX()括号中的值都可以是-50%缺点：transform是CSS3的新属性，所以兼容性比较差 2.4.2 relative–transform123456789101112131415161718192021222324&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; position: relative; left: 50%; transform: translateX(-50%); background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我仙女&lt;/div&gt;&lt;/div&gt;&lt;div class=\"wrap\"&gt;&lt;/div&gt; 说明：这个方法与2.4.1极相似，不同之处在于，此法外盒子不定位，直接给内盒子采取相对定位relative，但一般不会这样使用，都是采用上面那种方法注：transform方法，当计算结果含小数位时，会导致整个元素变模糊，解决方案是父级元素设置transform-style:preserve-3d; 2.5 table-cell/inline-block2.5.1 table-cell12345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; display: table-cell; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; margin: 0 auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 优点：实现简单，内盒子宽度无须固定缺点：table-cell会跟浮动、定位等属性相互冲突，并且不能设置margin属性 2.5.2 inline-block 112345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; display: inline-block; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; margin: 0 auto; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我小仙女&lt;/div&gt;&lt;/div&gt; 2.5.3 inline-block 212345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; text-align: center; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; display: inline-block; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我仙女&lt;/div&gt;&lt;/div&gt; 说明：把内盒子设成行内块元素，使用1中行内元素的居中方式 优点：内盒子宽度无须固定 2.6 flex12345678910111213141516171819202122&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; display: flex; justify-content: center; background: paleturquoise; &#125; .in&#123; /* width: 100px; */ width: fit-content; background: peachpuff; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"in\"&gt;请叫我仙女&lt;/div&gt;&lt;/div&gt; 说明：justify-content:center;意为flex主轴方向对齐方式：居中。主轴方向flex-direction默认为row即横向注：如果内盒子不设高度，外盒子使用flex属性后，会出现如下现象因为外盒子没有设置垂直方向上的对齐方式align-items，而它的默认值是stretch即铺满容器，所以就出现了内盒子高度等于外盒子高度，所以未避免这种情况，可以根据需求设置align-items对齐方式，此处可添加align-items:flex-start;即顶端对齐关于flex可以参考我的博客 优点：实现简单，内盒子宽度无须固定缺点：flex为CSS3新属性，兼容性差，且flex内的元素float、clear、vertical-align等样式全部失效 2.7 增加节点1234567891011121314151617181920212223242526&lt;style&gt; html,body &#123; margin: 0; padding: 0; &#125; .wrap&#123; width: 200px; height: 200px; background: paleturquoise; &#125; .in&#123; width: 100px; float: left; background: peachpuff; &#125; .hide&#123; width: 50px; height: 1px; float: left; &#125;&lt;/style&gt;&lt;div class=\"wrap\"&gt; &lt;div class=\"hide\"&gt;&lt;/div&gt; &lt;div class=\"in\"&gt;请叫我仙女&lt;/div&gt;&lt;/div&gt; 说明：在内盒子前添加一个元素，并且设置宽为内外盒子宽度差的二分之一，高为1px,两个元素都设置float,其实这种方法跟2.1原理是相同的，此处.hide的位置即为2.1中margin-left所占据的位置 优点：请原谅我从宏观上看并没有发现此方法的优点，但不代表这种方法没有用，或许在某些复杂或奇怪的页面结构中，其它方法都不适用，只能采用这种方法呢缺点：需要增加元素节点，并且用到浮动属性增加页面复杂度，且内盒子宽度固定 3 总结关于水平居中的方法就总结到这里了，如果小伙伴们还有其它方法，或者在具体的实践中遇到任何问题，都欢迎大家在评论区积极讨论，我也会一直关注的哦✌","tags":[{"name":"css","slug":"css","permalink":"http://yyeggs.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yyeggs.com/tags/html/"}]}]